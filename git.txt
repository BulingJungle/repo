cd
mkdir
pwd

touch he.txt

git init

git add			(use "git add <file>..." to update what will be committed)
git commit -m ""	引号内添加修改注释，便于查看具体改动了哪些内容
			ps:add和commit的区别在于，add可以添加多次不同的文件到仓库，而commit可以一次提交多个文件到仓库。add为提交前的准备工作。

git status		git status命令可以让我们时刻掌握仓库当前的状态
git diff		如果git status告诉你有文件被修改过，用git diff可以查看修改内容
git log 		查看历史记录，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数
			git的版本号是SHA1计算出的很大的十六进制数，用于区别不同的版本
			每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线
git reset -hard HEAD^	版本回溯，首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100
cat he.txt		查看内容
git reflog		在Git中，总是有后悔药可以吃的。
			当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，
			就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令

git reset --hard commit_id	

工作区:在电脑磁盘创建的文件夹，在这个文件夹内git init，那么这就是我们的工作区

版本库：
	工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库
	Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD
	git add把文件添加进去，实际上就是把文件修改添加到暂存区
	git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支
	因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改
	可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改
	如果一个文件的状态是Untracked，那么该文件还未被add到git暂存区
	然后，执行git commit就可以一次性把暂存区的所有修改提交到分支，暂存区的东西一经提交，则将变为空

git的优秀之处：为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件

git restore 			放弃工作目录中的更改，在add前可以操作,
				
git restore --staged 文件名 	如果add以后那么可以使用staged参数进行操作，然后重复执行git restore即可
git reset --hard 版本号		当你已经将修改了的内容提交到分支以后，回溯以前的版本

当涉及到删除的改动时，如果确实想删除，那么git rm 久可以删除，但删除了文件还是要commit到版本库中
git rm				用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容
				只要被删除的版本已经提交过分支了，那么误删都可以恢复
				注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！


git的强大之处：远程仓库，分布式版本控制系统（同一个仓库可以分布到不同的机器上）
	       一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下	
	       本地Git仓库和GitHub仓库之间的传输是通过SSH加密的
		1.创建SSH
		$ ssh-keygen -t rsa -C "youremail@example.com"
		密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa
		用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息
		输入完毕后程序同时要求输入一个字符串(passphrase)，该字符串为保存SSHkey代码的文件的文件名，推荐默认。接着会让输入2次口令(password)，空表示没有口令，口令为push文件时需要输入的密码。3次回车即可完成当前步骤，此时[c盘>用户>自己的用户名>.ssh]目录下已经生成好了。
		登录github。打开setting->SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中，再为当前的key起一个title来区分每个key。
		使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码
		用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人

		登陆GitHub，打开“Account settings”，“SSH Keys”页面
		点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容
		为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
		GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了
		github代码托管平台默认是公开的，私有的话别人无法提交。不过私有的库需要收费
		“如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。”
		你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得

		注意：在GitHub创建远程仓库需要是空的，否则push不上去。
	
		添加远程仓库：（添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库）
		关联远程仓库：
			$ git remote add origin git@github.com:michaelliao/learngit.git	
		把本地仓库推送到远程仓库（用git push命令，实际上是把当前分支master推送到远程）：
			$ git push -u origin master	由于远程库是空的，我们第一次推送master分支时，加上了-u参数
							Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
		从现在起，只要本地作了提交，就可以通过命令：
		$ git push origin master
		把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！

		SSH警告：
			当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：
			The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
			RSA key fingerprint is xx.xx.xx.xx.xx.
			Are you sure you want to continue connecting (yes/no)?	
			这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。

			Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：

			Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
			这个警告只会出现一次，后面的操作就不会有任何警告了。	

用命令git clone克隆一个本地库：
		$ git clone git@github.com:michaelliao/gitskills.git
		GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。		
		要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。支持多种协议，包括https，但通过ssh支持的原生git协议速度最快	

git分支管理：
	可以创建自己地分支别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作
	HEAD指向当前分支
	创建分支并切换分支（HEAD指向新创建的分支dev）：
		git checkout -b dev	
		等同于
		git branch dev
		git checkout dev
	查看当前分支：
		git branch	git branch命令会列出所有分支，当前分支前面会标一个*号
	然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行，完成后add
	现在，dev分支的工作完成，我们就可以切换回master分支(HEAD自动指向当前分支):
		git checkout master
	但是在合并到主分支master之前，在dev分支所做的修改不会影响主分支
	现在，我们把dev分支的工作成果合并到master分支上：
		git merge dev		将master指向dev所做的文件上	
	Git鼓励大量使用分支：

			查看分支：git branch

			创建分支：git branch <name>

			切换分支：git checkout <name>或者git switch <name>

			创建+切换分支：git checkout -b <name>或者git switch -c <name>

			合并某分支到当前分支：git merge <name>

			删除分支：git branch -d <name>
		注意：如果master分支和feature1分支各自都分别有新的提交，这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突

			$ git merge feature1
			Auto-merging readme.txt
			CONFLICT (content): Merge conflict in readme.txt
			Automatic merge failed; fix conflicts and then commit the result.
			
			Git告诉我们，he.txt文件存在冲突，必须手动解决冲突后再提交
		解决冲突：
			修改master对应文件，add和commit后即可	
			当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
			解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。
			用git log --graph命令可以看到分支合并图。

分支管理策略：
		通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息
		如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息
		所以就用，--no-ff方式的git merge

		$ git merge --no-ff -m "merge with no-ff" dev

		这次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
		使用该模式最大的特点就是在merge分支后，仍然能保留分支的信息

分支策略:
		在实际开发中，我们应该按照几个基本原则进行分支管理：

		首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

		那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

		你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
		
		注意：合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

BUG分支：
		在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除
		当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交
		并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？

		幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
		$ git stash
		注意：想修复主分支的bug，就需要在主分支上创建分支，需要将checkout回主分支，再创建bug修复分支，修复完了再合并的主分支
		修复完毕了以后，这时就可以切换回刚刚还没完成的工作分支dev：
		$ git checkout dev
		用git stash list命令看看：
		$ git stash list
		stash@{0}: WIP on dev: f52c633 add merge	
		工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：
		一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
		另一种方式是用git stash pop，恢复的同时把stash内容也删了，删除后：
		再用git stash list查看，就看不到任何stash内容了：
		$ git stash list
		但是，想一想dev也是主分支的分支，那么主分支的bug也会出现在当前的dev分支上，主分支的bug修复了，但是dev上的还没
		那么，有什么办法使得dev的bug也能被修复了，难道还要在dev上建立一个分支吗？
		答案是：不用那么麻烦
		将之前修复主分支的那次提交修改“复制”到dev。
		注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。
		为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：
		$ git branch
		* dev
 		 master
		$ git cherry-pick 4c805e2
		[master 1d4b803] fix bug 101
		 1 file changed, 1 insertion(+), 1 deletion(-)
		Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit

		小结
		修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；

		当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；
	
		在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。





















	
