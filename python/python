 CTRL+ALT+ENTER全屏切花，CTRL+ALT+T打开Lniux的命令行  终止正在运行功能的终端-->ctrl+c
tar -xjvf 解tar.bz2包
exit---->直接退出终端的命令
mysql中ctrl+c+回车退出输入

$命令 [选项] [参数]
如：$pwd /usr/bin -l   
有些命令没选项或者参数
				  	
路径或目录：
Windows： 如：   E:\KwDownload\Lyric
Linux： 如： /usr/bin/...	

绝对路径和相对路径

绝：以'/’字符开头	唯一标识一个文件或者文件夹的路径
相对：不以/开头	.开头为当前文件夹
		..开头为上级文件夹
		～为用户主目录

Linux操作系统常用命令：
		 
pwd命令--》显示当前操作路径
cd-->进入某路径      cd / #进入根目录	cd #默认进入用户目录	cd .. #进入上级目录  cd - 进入历史上次目录
ls---> -l 列表显示文件的详细信息 -a显示全部文件/文件夹信息
mkdir--->创建一个或多个文件夹	常用选项: -P 如果中间文件夹不存在，则逐级创建所有文件夹		
rmdir--->删除一个或多个文件夹（空文件夹才可删除）		  -P如果中间文件夹不存在，则逐级删除中间的空文件夹
tree-->显示目录树 需安装  $sudo apt install tree 回车 输入密码
touch--->创建文件 1.若文件不存在，则创建一个空文件 2.若文件存在，用系统时间更新他的修改时间   
rm--->删除文件  格式：rm [选项] 文件/文件夹	常用选项 -r递归删除文件夹内部的全部文件或文件夹  -i删除前给出提示
							 -f 强制删除，不给任何提示
						几种选项可以搭配使用    
--help选项---->查看命令的各种选项

man帮助命令     格式：man Linux/UNIX命令名
	        作用:参看命令对应的手册
		实例：man ls 	man mkdir
		说明：退出键q

Tab键		作用：自动补全   比如有时候记不住命令了，只记得部分；文件名字也可以补全，很好用。写一部分就可以用Tab了
History命令	作用：将以前键入的历史命令都罗列出来	

通配符（常用于查找文件，类似正则表达式的思想）
		*代表0个或者多个任意字符
		？代表一个任意字符
		如有下列文件：a ab acsd  bc ac
		a*可以代表所有以a开头的文件
		a*b代表所有以a开头以b结尾的文件
		a?代表ab ac
		?c代表ac bc
subl---》sublime文本编辑器打开文件
	实例：subl /home/ran/day01.txt
	subl .  打开当前文件夹
	view->slider->show side bai 打开侧边栏（文件夹才有）
	sublime可以写代码
	sublime快捷键：ctrl+ b k 
		       ctr l+鼠标滚轮（字体放大缩小）	
			ctrl+鼠标左键（创建多个光标）
			Ese取消多个广标
			ctrl+d选择多个相同的词，可以批量修改。
			注释:ctrl+/
			ctrl+shift+上下键  行交替
			重做、返回上一步：ctrl+z  ctrl+y	
	
cat命令---->将文本文件的内容作为标准输出显示出来
	格式：	cat [文件1] [文件2] ...
	实例： cat hello.txt

cp命令--->将源文件/夹复制到目标文件
	格式：cp [选项]	源文件或者文件夹 目标文件或者文件夹
	常用选项：-a 复制文件夹及其内容
	注意：拷贝文件夹需要加选项
mv命令--->文件搬移或更名

	格式：mv [选项] 源文件 目标文件
	或者：mv [选项] 源文件 目录
find命令---->根据文件名称等信息查找指定的文件
	常用格式:find 路径 -name "文件夹名或文件名"
	实例：find / -name "day01.txt"	以根目录下开始寻找
grep命令---->查找文件中相应的内容及文本信息	 print lines matching a pattern
	格式：grep "内容" [选项] 文件名或文件夹 
	常用选项：-n 显示行号	
		  -r递归搜索文件夹内的文件
	
查找“gzip”文件在什么位置：find / -name "gzip"
查找/etc文件夹下的哪些文件里含有"tarena"：grep "tarena" -nr /etc


gzip命令--->
	作用：用zip无损压缩算法对文件进行压缩，生成压缩文件	
	格式：gzip 文件名
	压缩后文件后缀变为.gz
gunzip--->解压缩，解.gz文件
	格式：gunzip 文件名（需要是.gz文件）
	实例:gunzip test.txt.gz
tar命令---->对文件或者文件夹进行打包和解包的操作
	格式：tar [选项] 文件名和路径
	常用选项：
		-c 		创建包（打包  ）
		-x 		解包
		-f 文件名	操作的文件名
		-v		显示操作的文件细节
		-z		用gzip/gunzip对包进行压缩或解压
	注意：tar打包后的文件后缀为.tar	
	实例：tar -c -v -f result.tar（生成的打包文件） day01（需要打包的文件或文件夹） 
	ran@ran-virtual-machine:~/Desktop$ tar -c -v -f result.tar myfiles/	（将myfiles文件夹打包成reslt.tar）
	tar -x -v -f result.tar 解包
	
文件的权限管理及命令：
	查看文件：ls -l

文件的权限类型：
	-r读权限，具有读取文件内容的权限
	-w写权限，具有新增，修改，删除文件内容的权限	
	-x执行权限，具有执行文件的权限(文件名当作命令用)
	-无权限

权限的分组：用户权限user，组权限group，其他other 
	实例：	rw- 可读可写但不可执行
		r--只可读
		---不可读写执行
最高权限：rwxrwxrwx（三个为一组）
最低权限：---------

如何在linux中修改文件的权限：
	chomd 666 文件名 	#给文件加权限，可读可写
	chmod 777 文件名 	最高权限
	chmod命令---->修改你文件权限
	格式：chmod 权限 文件名/文件夹名
	权限：
		u 用户
		g 同组用户
		o其他用户
		a 所有用户
		+ 加权限
		- 去除权限
	示例：chmod u+r a.txt	
	      chmod o-rwx a.txt

可以将linux命令写到.sh（Linux里面的文本可执行文件），相当于批处理 
bash程序控制着linux命令的解释执行

输出重定向：linux里面分为标准输出及错误输出
标准输出重定向： >	将一个命令的标准输出重定向到指定文件里
		 >>	将一个命令的标准输出追加到指定文件末尾

	   例：
		find /etc -name "group" > output.txt	相当于把命令的正确输出，输出到output.txt。多次运行同一代码不
							会产生重复结果。而两个大于号可以追加，不论输出结果是否重复。
		
标准错误输出重定向：	2>	将一个命令的错误信息重定向到指定文件里
		 	2>>	将一个命令的错误信息追加到指定文件末尾

重定向所有输出：	&> 	
			&>>
			将所有输出信息重定向到文件

/dev/null文件：写入到此文件的内容全部被丢弃，为虚拟设备文件。无限大的文件，可以将一些大量的无用的东西放在这个文件里

clear命令：
	作用:清屏
	快捷键：ctrl+l
	

——————————————————————————
python阶段

python为解释性语言，简单高效优雅应用领域多

应用领域：系统自动化运维，网络编程（搜索引擎，爬虫，服务器编程等）
科学计算
人工智能，机器人
web开发
云计算
大数据及数据库编程
教育及游戏等..

python优点：    面向对象
		免费
		可移植
		可混合编程
		简单高效
		开发效率高
		应用广泛
		开源
缺点：		与c/c++比速度不够
		不能封闭源码
		不能写操作系统内核和驱动程序
		
		
python官网：www.python.org
python版本：python不向下兼容低版本
	v2.7（2020年结束维护）
	v3.5当前学习版本
	v3.8最新版本

编译型语言和解释型语言的区别：解释性语言需要解释器才可运行，编译型则一次编译就直接可以运行，不依赖
				所谓的解释器

python解释执行器类型： Cpython（用C语言写的）
		       Jython（java语言开发）
		       IronPython（.net开发，C#)

在python的文件中，需要在第一行加上	#！/usr/bin/python3
告诉终端是以python3的解释执行器来执行的，如果不加当在终端上直接调用.py文件则终端会用bash来执行。

python核心数据类型：
	数值型（整数，浮点数，复数型，布尔型）
	整数int的字面值表示方式：
		八进制：（0o开头，后跟0~7）	如0o177（127）
		十六进制（0x开头，后跟0~9，A~F，a~f）	如：0x11(17)
		二进制表示方式（0b开头，后跟0~1）	如0b1001

	浮点数：
		两种表示：小数表示：3.12 
				    3.0 
				    3. 
				    0.12 
				    .12
	
			  科学计数法：
				格式：小数e/E（正负号） 指数
				   如：6.18E-1
					2.9992e8
	复数（complex）
		分为两部分: 实部（real）和虚部（image）
		注意：虚部必须是以j或J结尾的数
		如：1j	1+1j	1-1j	-119+100j等

	布尔型：true1 false0
	None空值：表示一个不存在的特殊对象,仍然是一个对象
	作用：1.用来语法占位
	      2.变量解释绑定

表达式（expression）和运算符：	
	由数字或数字和运算符组成
	作用：让计算机做一些事，并返回结果
	
运算符：
	1）算术运算符：+	-	*	/（python的除法不会丢掉小数部分）
		      //（地板除，floordiv，python2.3后。如：7//2=3，相当于丢掉余数部分）
		      %求余 	如：7%3=1
		      幂运算**
		PS：混合运算,自动升级	如:1+1.3=2.3
	 		
运算符的优先级：乘方>乘除，求余，地板除>加减

基本的输出函数：print
	示例：print("hello")	print(1+2)	print(1+2,3+3,4+3)
	可以是字符串也可以是表达式


变量名命名法：为字母或者下划线开头，后跟字母，下划线或者数字（类似C系语言）
	PS：python变量名区分大小写

python关键字：True，False，None，is，del，if，elif，else，pass，not...等33个

赋值语句（statement）：变量名=表达式，或，变量1=变量2=表达式，或，变量1，变量2，...=序列
	作用：将变量绑定于对象上,代表着一个对象（记住河岸的桩拴住船的例子）
	说明：
	      当变量不存在时，创建该变量，并绑定对象
	      当变量存在时，改变这个变量的绑定关系
	      一个变量只能绑定一个对象
	      两个变量可以同时绑定到同一个对象（一个变量只对应一个对象的引用）

python自动内存管理：当对象与变量的引用关系失去时，对象所占内存将被自动释放

python关联/绑定/引用的含义：都是指变量和对象的关联关系
	ps:python中的变量没有类型
	 示例：a=b=c=30	#abc三个变量都指向30这个对象 
	 	a=1，b=2，c=3可以写成a,b,c=1,2,3
交换数值方法：一是可以用C的经典交换方法（利用中间变量），二是可以这样： a，b=b，a

is/is not运算符
	is作用：判断两个对象是否是同一个对象，是则返回true，否则返回false
	is not则与is作用相反

小整数对象池：cpython中，整数-5到256永远处于内存中不会被释放
	
id函数：
	作用：返回一个对象在内存中的地址
	格式：id（对象）
	1byte（字节）=8bit（位），一个位是0或1

del 语句
	作用：用于解除变量与对象之间的引用，必要时自动清理内存

自动化内存管理与引用计数：一个对象可以被多个变量来指向，当引用个数为0时，则该对象所占内存会被自动释放

复合赋值运算：+=,-=,*=,/=,//=,%=,**=

比较运算符：< 	<=	>=	==	!=（返回布尔值）	


数值对象的构造函数：
	float（obj）		用字符串或数字转换为浮点数
	int（x="0"，base=0）	用数字或者是字符串转换为整数	如果不给参数则返回0	
				base指x的类型，若是2则代表x为二进制，也可以是其他数字，如：int("11",base=8),结果为9
				int（“1001”，base=2）也是9.base默认为10
	complex（r=0.0，i=0.0） 用数字创建一个复数（r为实部，i为虚部） 如:complex(1,100)  就等于1+100j
	bool（x）		用x创建一个bool值。python中任何对象都可以用这个函数返回1或0


函数的调用:函数名（传参列表）

	
python内建数值型函数：
	abs（x）			绝对值函数
	round（number[，ndigits]）	对数值进行四舍五入（大于五才进）
					nidigits是小数向右取整数的位数，负数表示向左取整；
					例如：round（3.13324123,3）为3.133；round（3234.23，-2）为3200.0
	pow（x，y，z=None）		相当于x**y或x**y%z
	help(函数名)			比如:help(abs)，作用是查看abs函数的帮助文档	
	
语句（statements）
	语句是python执行的最小单位，语句可以独立执行。;（分号）是语句的分隔符，通常一条语句写一行。

折行符：/
	作用：如果非要将一条语句写到多行，则在一行的末尾加上一个折行符（续行作用）

隐式换行：所有括号都是成对出现，所以程序会自动搜索下一右括号。所以，利用该功能就可以将一条语句写到多行。

基本输入函数：input
	作用：从标准输入设备上读取一个字符串(PS:末尾的换行符会被删除）
	格式：input（"提示字符串"）
	      注：返回一个字符串

基本输出函数:print(value,..,sep='',end='\n')
	作用：将一系列对象的以字符的形式输出到标准设备上
	关键字参数说明:
		sep：为两个值之间的分隔符，默认是一个空格' '
		end：为输出完毕后自动在流末尾追加一个字符串，默认为换行符'\n'
	
if语句
	让程序根据条件执行语句
	格式：if 真值表达式
		语句块
	      elif 真值表达式2
		语句块2
	      elif 真值表达式3
	      ...
	      else： 
		  语句块
	PS:python里面可以这么写：1<=number<=3  	但C语言是：1<=number && number<=3

if语句的嵌套：
	if语句可以嵌套if
	如：if 1<=num<=12）		大前提，满足这条if语句后才可执行下面的嵌套的if语句
		if num<=3:
		print("春季")
		elif ...:
		..
	   else:
		..
语句、表达式、运算符、字面值、函数调用的关系：
	语句（表达式（运算符，字面值,函数调用）） 
	比如：赋值运算符右边一定是表达式

条件表达式:（类似于C语言的三元运算符）
	语法：表达式1 if 真值表达式 else 表达式2
	作用：
	如果真值表达式的布尔值为true时，则执行表达式1，并返回结果对象的引用，否则执行表达式2
	并返回对象的引用
	例子：
		#商场促销，满一百减二十
		money=int（input（“输入金额：”））
		pay=money-20 if money>=100 else pay=money
		print（pay）

	例子：  num=int(input("plz input a number:"))

		print("abs is ",num) if num >=0 else print("abs is ",-num)
	上面例子还可以这样写：print（num if num >=0 else -num）


Pass语句：
	作用:
		通常用于填充语法空白
	示例：
		比如if语句满足后，不想让程序做什么就用pass语句
		if 1<=season<=4:
			pass
		else:
		        print("input error!")

布尔运算：	
	运算符：and or not（相当于C语言的&& ! ||）

布尔非操作：
	语法：
		not x
	作用：对x取布尔非

布尔与操作：
	语法：x and y
	注：x，y代表表达式
	作用：优先返回假值对象，当x的布尔值为false时，返回x，否则返回y。同真为真，一假为假。
	示例：
		true and true	返回true
		false and true 	 返回false
		false and false  返回false ，返回前面那个false
	
	if gender=“男” and age<=30
	print（“可以面试”）

		
	注意：and操作，返回的是x或者y，因为在python中任何一个对象都有真或假的状态。一般
	      0为假，非0为真。回车输入的空字符串的布尔为false。‘0’为true

布尔或操作：
	运算符：or
	语法：	x or y		等同于bool（x）==true else y
	含义：优先返回真值对象，当x为true时，返回x，否则返回y
	注意:
	s=input（“输入成绩：”） or '0'
	score=int（s） 	
	int无法转空字符串（输入回车键的那个为空字符串）
	功能等同于下面代码：
	s=input（“输入成绩：”）
	if s==‘’：
	s=‘0’
	score=int(s)

正负号运算符


str字符串:
	字面值表示方法：
		用引号括起来的部分
	单引号
	双引号
	三单引号	'''hello'''
	三双引号	"""hello"""
	（都成对出现，作用基本相同）
	三引号字符串的作用：三引号内可以包含单、双引号
	三引号字符串中的换行会被自动转换为\n
	三引号可以保留字符串的格式

隐私字符串字面值拼接：
	多个字符串写在一起，视为一个字符串




转移序列：	
	在字符串中使用特殊字符，可以用反斜杠\加想要添加的特殊字符，格式：\+特殊字符
	反斜杠转义字符表：
		\'
		\"
		\\
		\n	换行符
		\r	返回光标至首行
		\f	换页
		\t	水平制表符
		\v	垂直制表符
		\b	退格，相当于按下backspace键  
		\0	字符串，字符值为0	
		\xXX	XX为两位十六进制表示的字符,可以将ASCII编码转义的为字符 
		\uXXXX	unicode16的十六进制表示的字符
		\UXXXXXXXX	Unicode32的十六进制表示的字符

		
ASCII编码
	码表见：$man ascii
	字符的对应编码，及键盘上的按键对应的编码
	常见的ASICII编码：
		字符		十进制		十六进制
		'0'		48		0x30
		'A'		65		0x41
		'a'		97		0x61 
		'\0'		0		0x00	
		'\n'		10		0x0A

Unicode编码：
	全世界字符统一编码	
		分类：	
			UNICODE16(两个字节表示，16位 )	如：\u9024 代表的是中文‘遂’
							    \u0061为a
			UNICODE32	能装更多的字符类型。如：\U00009024	代表中文字‘遂’
	
raw原始字符串
	格式：r+字符串
	作用：当字符串中含有转义字符\，能使该字符串中的转义字符不起作用
	例子：
		print(r'C:\newfile\test.py')

字符串的运算：
	+	拼接字符串
	+=	在原字符串的基础上的右侧拼接字符串，形成新的字符串。相当于追加
	*生成重复的字符串
	*=生成重复的字符串并让原变量绑定生成后的字符串
	例子：	
		s=“ABC”*3	#s=“ABCABCABC”
		
字符串的比较：
	运算符：>	>=	<	<=	==	!=
	格式：x>y
	规则：首先拿字符串的第一个字符比较，如果相同，再取第二个进行比较。以此类推，如果出现一个不同，则得出结果
		
	      比较的是字符的编码(unicode)

	示例："AD">"ABC"	#True

in /not in运算符：
	作用：用于序列、字典、集合等容器中，用于判断某个值是否存在于容器之中
	格式：对象 in 序列/字段/集合
	例子：
		str="ABC"
		print('A' in str)	#True

字符串的索引
	字符串也是一种序列，有序排列
	下标从0开始，最后一个为lens-1
	第一个也可以是-lens，倒数第一个为-1
	所以，分为正向索引，以及有逆向索引
	求字符串的长度：len（str）
	str="ABCD"
		A	B	C	D
	正向	0	1	2	3
	逆向	-4	-3	-2	-1

		
切片 Slice
	从字符串中取出子串，形成新的字符串序列
	语法：

		字符串名[(开始索引b):(结束索引e)(:(步长s))］
		注意：小括号括起的部分代表可以省略。结束索引要指定到下一个值，不会切结束索引所在的值
		      如果起始索引没有给出默认为第一个开始，如果结束索引没有写相当于切完最后一个字符
			开始索引和结束索引可以超过字符个数。当结束索引和开始索引相等时，切出来的是空串
		步长：是切片每次获取完当前元素后向右移动索引的跨度（默认为1）
		      步长可正可负，为正时为正向切片。负为反向切片。
		      反向切片时，默认起始位置为最后一个元素，终止位置为第一个元素的前一个位置			
		示例：	
			str="ABCDE"
			sli=str[-1:-4:-1]	#sli=EDC	反向切片
			sli=str[2:5:1]		#sli=CDE	正向切片
			sli=str[:5]		#ABCDE	
			sli=str[:-2]		#ABC
			sli=str[:-2:2]		#AC
			sli=str[-1:0:-1]	#EDCB
			sli=str[::-2]		#ECA

python3常用内置函数：
	len(seq)	返回序列长度
	max（x）	返回序列的最大值元素
	min（x）	返回序列的最小值元素


字符串编码转换函数：
	ord（x）	返回一个字符的Unicode编码值（0~65535）
	chr（i）	返回i这个值对应的字符

	
整数转换为字符串函数：
	hex（i）	将整数转换为	十六进制字符串
	oct（i）			八进制
	bin（i）			二进制


字符串构造函数：
	str（obj=''）	将对象转换为字符串



python3中常用内置的字符串方法：

	对象.方法名（参数列表）
	S代表为str对象
	S.isalpha（）				#判断S中是否全部为英文字母
	S.isdigit（）				判断S中是否全部为数字
	S.islower()				判断是否全为小写
	S.isupper()					   ~大写
	S.isspace（）				判断是否为空白字符（如：空格，水平制表符，换行符等不可见字符）
	S.iscenter(width,[,fill])		将原字符串居中对齐， 左右默认填充空格
						第一个参数为多少个空格，第二个指定填充字符
						例子："Abc".iscenter(10,'#')
	S.count(sub[,start[,end]])		在S中寻找是否有匹配的子串与给定的字符串相等
						start与end可以指定开始寻找和结束寻找的字符的位置，optional
						例子： S="hello world"
						       S.count（"O"）	# 2
	S.find(sub[,start[,end])		寻找字符串S中指定子串的索引

	S.strip（）				返回去掉左右空白字符的字符串
	S.lstrip（）				返回去掉左侧空白的字符串
	S.rstrip()				~
	S.upper()				转大写
	S.lower（）				转小写
	S.replace（old，new[,count]）		将原字符串中的old用new替换
	S.startswith（prefix[,start[,end]]）	返回一个布尔值，如果以prefix开头，返回true.从S的左端开始比较
	S.endswith（prefix[,start[,end]]）	
	
	不常用的：
		S.title（）		将字符串中每个单词的首字母大写
		S.isnumeric		判断字符串是否全为数字字符

		

字符串的格式化表达式：
	作用：生成一定格式的字符串（其实相当于调用str函数）
	运算符：%
	格式：格式化字符串 % 参数值	或	格式化字符串%参数1，参数2，...
	例子:	
		fms="姓名：%s，年龄：%d"	#%为占位符，d为类型码
		fms % （"张飞","20"）	# '姓名：张飞，年龄：20'

	占位符类型码（类似C中格式化输入输出）：
		%s	字符串
		%r	字符串，使用repr而不是str
		%c	整数转为单个字符
		%d	十进制整数
		%o 	八进制整数
		%x	十六进制整数（a-f）
		%X	十六进制整数 (A-F)
		%e	指数型浮点数（e小写）
		%E			大写
		%f,F	浮点十进制形式
		%%	等同于一个%字符
		例子:	
			fms="%c" % 41
			print(fms)

占位符 % 和类型码之间的格式语法：
	% [格式语法] 类型码（d，s，f等）
	格式语法：
		-	左对齐
		+	显示正负号
		0	补零
		宽度
		宽度.精度
	示例1：
		"%10d"   %  123		#"       123"
		"%+10d"  %  123		#"      +123"
		"%010d"  %  123		#"0000000123"
 		"%-10d"  %  123		#"123       "
		"%10s"	 %  "abc"	#"       abc"
		"%-10s"  %  "abc"	#"abc       "
		"%43.2f"%23421.321323	#43个字符的宽度，保留小数点后2位
		"%.2f"%3.14159		#3.14
	
	示例2：
		str1=input("first  str:")
		str2=input("second str:")
		str3=input("thrid  str:")
		print("%20s" % str1)
		print("%20s" % str2)
		print("%20s" % str3)	#占20个字符，右对齐输出

	

循环语句：
	while语句与for语句
	1.while语句
		语法：while 真值表达式：
			语句块1...
		      else：
			语句块2...

		说明：先执行真值表达式，如果真值表达式为true，则执行语句块1，然后再执行真值表达式，若为真，还是
		      执行语句块1，否则执行else语句块2的内容。
		      else子句可以省略。
		例子：
			i=1
			while i<=10：
				print（"HELLO"）
				i+=1
			else：
				pass
		注意：注意控制真值表达式的值防止出现死循环
		      一般为循环变量，来控制循环条件
		      通常在循环语句块内，改变循环的变量，来控制循环的次数和语句的走向。

while 语句循环的嵌套：
	可以嵌套于其他的复合语句（if，while，for等语句的内部）

break 语句：
	作用:用于循环语句（while，for语句）中当前语句的终止，
	说明：  break执行后，将跳出循环，后面的else子句不会被执行
		break语句通常和if语句组合使用
		break只能跳出当前循环体的执行，如果有嵌套循环，将不会跳过外层循环	
		通常用break跳出死循环

 
for 循环：
	作用：用于遍历可迭代对象的数据元素
	语法：
		for 变量列表 in 可迭代对象：
			语句块1
		else：
			语句块2
	语法说明：
		1.可迭代对象每次提供一个元素依次赋值给变量列表中的变量，赋值完毕以后执行语句块1，重复执行此步骤
		2.当可迭代对象不能提供数据时，执行else子句部分的语句块2，然后退出循环
		3.else子句部分可省略
		4.当在语句内部使用break终止循环时，else子句部分将不会执行
	名词解释：
		1.可迭代对象：指能依次获取数据元素的对象
	

Range 函数:	
	作用:
		用于创建一个生成一系列整数的可迭代对象，也叫做整数序列生成器
	调用格式：
		range（stop）	#stop只能为整数
		从零开始，每次生成一个整数后加1操作，直到stop为止（不包括stop）
		range（start,stop[,step])
	示例：
		range（4）	#生成0 1 2 3
		range（3，6）	#3,4,5
		range（1,10,2）	#1,3,5,7,9
		range（5,1，-2）#5,3

for 循环语句嵌套：
	 示例：
num_=int(input("a number:"))
for i in range(1,num_+1):
	print(i,end=" ")
	j=i+1
	for j in range(j,i+num_):
		print(j,end=" ")
	print()
else:
	print()

输入5：
1 2 3 4 5 
2 3 4 5 6 
3 4 5 6 7 
4 5 6 7 8 
5 6 7 8 9



continue 语句：
	作用:用于循环语句（while，for语句）中，不再执行continue语句后的内容，直接跳过本次循环执行新的循环
	说明：
		1.在while语句中，执行continue，将直接跳转的while语句的真值表达式，重新判断循环条件
		2.在for语句中，执行continue将会取可迭代对象的下一个值，并绑定变量后再次进行循环。

python3 序列：
	字符串 str
	列表 list
	元组 tuple
	字节串 bytes
	字节数组 bytearray


列表 list
	定义：由一系列元素组成，元素之间可能没有任何的关联关系，但有先后顺序。元素之间可以是不同数据类型。
	      是一种容器，是一种序列，可以改变元素的顺序。（可变数据类型）
	创建：
		L=[]	#L绑定列表，为空
		L=[1,2,3,4]	#创建非空列表
	求长度：len（列表名）
	添加元素：append（）
	内建函数（构造函数）：
		list()	作用等同于[]，创建一个空list
		list（iterable） #用可迭代对象创建list
	列表的运算：
		+ 	用于拼接列表，顺序按照拼接顺序
		+=	[1，2]+[3，4]=[1，2,3，4]
		*	生成重复的列表，如：[1，2，3]*3  	#[1,2,3,1,2,3,1,2,3]
		*=	
	列表大小的比较：
		运算符：
			< <= > >= == !=
		示例:
			[1,2,3] < [1,2,4]	#TRUE
			[1,3]  >  [1,2,4]	#TRUE

		比较规则：依次将每个元素进行比较。规则类似于字符串的比较规则。
		注意：两个list中不同类型的元素之间不可以进行类型比较
	列表切片：
		类似于字符串的切片，返回一个列表
	列表索引：
		类似字符串的索引
	列表的索引赋值：
	 列表是一个可变的序列，可以通过该方式，改变对应索引的值
	 示例:
		L=[1，2，3，4]
		L[2]=3.3	#将3改为3.3
	列表的切片赋值：	
		 作用：
			可以改变原列表的排序，可以插入和修改数据
			可以用切片改变列表的对应处元素的值
			相对于切片索引来说，切片赋值不仅可以改变某个索引下的值，还可进行删除，插入多个或一个元素
		 语法：
			列表[切片]=可迭代对象
			注：赋值运算符的右侧必须是一个可迭代对象
		 示例：
			L=[1,2,3]
			L[0:1]=[4，5]	#L=[4,5,2,3]
			L[0:0]=[0]	#L=[0,1，2,3]
		注意：1.对于切片步长不等于1的切片赋值，赋值运算符右侧的可迭代对象提供的元素个数一定要等于切片
			切出的段数
			例如：	L=[1，2，3，4,5，6]
				L=[::2]="ABCDE"	#错误的切片赋值
				L[::2]="ABC"	# L=[A,2,B,4,C,6]
						 


continue语句在while语句和for语句中的区别：
	while中跳转到真值表达式处
	for语句中跳转到可迭代对象取数据处


in / not in
	in和not in判断一个对象是否在一个容器内，结果返回布尔值

del 语句	
	用于删除列表中的元素（删除列表内部变量）
	语法：
		del 序列[整数表达式]
		del 序列[切片]
	示例：
		L=[1，2,3，4，5，6]
		del L[-1]	#删除最后一个元素6
		del L[0]	#删除第一个元素
		del L[::2]	#删除1,3,5
		
python3中常用于序列的函数：
	len(seq)	返回容器内元素个数
	（ 针对数值类型，x为一个序列）
	max(x)		返回容器内最大值
	min(x)		返回容器内最小值	
	sum(x)		返回所有元素和
	any(x)		真值测试，如果容器内其中一个元素为true，则返回true。否则false
	all（x）	真值测试，容器内所有元素的布尔值为True才返回True
	copy(x)		浅拷贝，赋值对象的副本
	append（x）	在序列中的末尾追加值
	extend(x)	相当于+=运算符，追加一个新列表
	clear(x)	清空列表
	sort(x)		排序
	reverse（x）	反转，用来改变原列表的先后顺序
	pop(x)		删除索引对应的元素，x为索引。可以返回该删除元素值
	详细见：
		>>> help（list）




浅拷贝和深拷贝：  
	深拷贝是所有对象都拷贝一次，浅拷贝只复制一层，浅拷贝相当于C#中的引用类型
	# L=[1,2]
	#L1=[3,4，L]
	#L2=L1.copy（）	进行浅拷贝，只复制3,4，而L为第二层数据，直接引用。
	深拷贝往往要导入模块
	示例：
		import copy
		copy.deepcopy（）	#将进行深拷贝，相当于复制对象的副本，相当于C#的值类型
	注意：深拷贝通常只对可变对象进行复制，不可变对象往往不进行复制

列表与字符串区别：
	列表和字符串都是序列，元素之间有先后关系
	字符串是不可变的序列，而列表是可变的序列
	字符串中每个元素只能存储字符，而列表可以存储任意类型的元素
	列表和字符串都是可迭代对象


字符串文本析方法：split和join
	S.split（sep=none）将字符串进行分割，以sep作为分隔符。返回切割后的字符串列表，默认以空格作为分割符
	S.join（iterable）用可迭代对象中的字符串，返回一个中间用S进行分割的字符串
	示例：
	S=“hello world”
	S.split（）	#返回["hello","world"]
	S.split("0")	#返回['hell','w','rld']
		
	L=["c:","program  files","python3"]
	s='\\'.join(L)	#s="c:\\program files\\python3"
	
列表推导式：
	用可迭代对象依次生成带有多个元素的列表的表达式   
	作用：用简易方法生成列表
	语法：[表达式 for 变量 in 可迭代对象
		或
	      [表达式 for 变量 in 可迭代对象 if 真值表达式] 
	思考：如何生成表达式[1,4,9,16,25,36,49]
	      简单方法：
			L=list()
			for x in range(1,8)
			     L.append(x **2)
	      用列表推导式：
		L=[x **2 for x in range（1,8）]
			
列表推导式的嵌套：
	语法：
		[表达式1 for 变量1 in 可迭代对象1 if 真值表达式1
		  	    for 变量2 in 可迭代对象2 if 真值表达式2]
	
元组 tuple：
	不可改变的序列，元组同list一样可以存放任意类型的元素，元素之间可以类型不同
	表示方法：
		小括号括起来
	创建空元组：
		t=（）
	创建非空元组：
		t=200，
		t=（20，）
		t=（1，2,3）
		t=100,200,300

type（）函数：
	可以用于判断变量的类型

元组的构造函数：
	tuple（）	生成空元组，作用等同于（）
	tuple（iterable）	iterable为可迭代对象，自动拆解

元组的运算：
	所有运算与列表的运算一致
	算术运算：+ 	+=	  *	*=	算术运算符右边也必须是元组 
	比较运算：> >= < <=
	in/not in	返回布尔值，与列表用法一致

元组的索引和切片：
	与列表的索引和切片用法一致
	切片时返回一个元组，列表的切片返回一个列表
	区别：元组不能索引赋值和切片赋值，但是可以取值的。因为元组是不可变的。

元组的内置方法：
	help（tuple）	    可以查看方法
	T.count（value）	返回元素个数
	T.index（value,[start,[stop]]）		返回某个元素在元组中的位置

序列相关函数：
	len（x）
	max（x）
	min（x）
	sum（x）
	any（x）
	str（obj）	将对象序列化为字符串
	list（iterable）
	tuple（iterable）
	reversed（sep）	返回可迭代对象的逆序对象
	sorted（iterable,reverse=False）	返回已排序的列表，生成新的列表
	
	注意：元组内可以存放列表，

字典 dict（通过哈希运算进行散列存储。键确定唯一的内存地址，内存地址是算出来的）
	可存放键值对的可变类型，字典的键不能重复
	{}
	{1:"Hello",2:"Yes"}
	构造函数：
		dict（）
		dict（可迭代对象）	
		dict（命名关键字传参）
	键索引：通过字典的键进行索引
	删除键： del dict（键）
	字典的成员资格判断：
		用in/ not in判断一个键是否存在于字典中，返回布尔值
		示例：
			d={1:"yes",2:"no"}
			1 in d	#true
			2 in d	#true
			3 not in d #true
			2 not in d #false
	列表的in运算符和字典的in运算符比较：
		字典in的操作速度快:列表in判断会因受到列表长度的影响，而字典in不会因为键值对的增加而增加
		  哈希存储与数量无关，通过计算找值得存储位置
	字典的迭代访问：
		对字典的迭代访问只能通过键进行访问
		例：	d={'name':"校长",'birthday':（2008,8,8）}	
			for k in d 
			   print("键:",k,"值",d[k])
	字典的内建函数：	
		len（x）	返回键值对个数
		max（x）	返回键的最大值
		min（x）
		sum（x）	返回所有键之和
		any（x）	对所有键进行真值测试，有真则返回true
		all（x）	对所有键进行真值测试，全真为true		    
	查看字典的方法：
		help（dict）
	D.clear（）	以下笔记省略D，情况字典
	pop（key）	移除键，返回该键对应的值
	copy（）	返回字典的副本，只复制一层(浅拷贝)
	D .update（D2）	将字典D2合并到D中，如果键相同则以D2进行更新
	get(key， default）	返回key键对应的值，如果没有此键返回默认，默认可自行制定
	keys（）	
	D.keys()	返回所有键
	D.values（）	返回所有的键的值
	D.items（）	返回所有的键值对，每个键值对为一个元组对象
	
	字典推导式：
		作用：
			用可迭代对象生成字典
		语法：
			{键表达式：值表达式 for 变量 in 可迭代对象[if 真值表达式]}
		注意：
			[]代表的内容可省略
		例子：
			#生成一个字典，键为10以内的数字，值为键的平方
			d={x:x**2 for x in range(1,10)}
		例子2:		
			L=["1001","1002","1003","1004"]
			L1=["Noe","Eov","Joe"]
			D={L1[x]:L[x] for x in range(len(L1))}	#range(4)生成0，1,2,3
			print(D)	#{'Joe': '1003', 'Noe': '1001', 'Eov': '1002'}
	字典推导式和列表推导式：
		1.都是可变对象
		2.索引方式不同：列表用整数索引，而字典用键索引
		3.字典的查找索引非常快
		4.列表的存储是有序的，而字典为散列存储。通过哈希运算


集合 set
	集合是不可变容器，集合内的数据必须是不可变对象
	集合内部数据对象唯一，没有重复
	集合是无序存储结构，数据间没有先后顺序
	集合内元素必须是不可变对象
	集合是可迭代对象
	集合相当于是只有键没有值得字典（键即是集合的数据）
	创建空集合，只能以此创空集合：set（）
	创建非空集合：s={1,2,3,4}
	集合的构造函数：
		set（）创建空集合
		set（iterable）以可迭代对象创建一个新的集合对象
	示例：
		s=set（）
		s={1,2,3,4}
		s=set（"abc"）#s={'a','b','c'}·
		s=set({1:"3",2:"4"}) #s={1,2}
		s=set(range(1:10:3)) #s={1,4,7}
		注意集合只能以不可变的可迭代对象来进行创建·
	集合的运算：
		交集，并集，补集，子集，超集
		运算符号：& 生成两个集合的交集     格式：集合1 & 集合2
			  | 生成两个几个的并集
		运算符：&  |  ^（生成两个集合的对称补集）  -（生成两个集合的补集）
	例子：
		s1={1,2,3}
		s2={2，3,4}
		s1-s2={1}
		s2-s1={4}
		s1^s2={1,4}

	in/not in 判断某个元素是否存在于某个集合内，返回布尔值
	集合in/not in 运算符的速度快于序列  
	
	用于集合的函数：
		len（x）
		max（x）
		min（x）
		sum（x）
		any（x）
		all（x）
	查看集合的方法：help（set）
	s.add（）
	s.remove（）	没有可删除的键则报错
	s.discard（）	即便没有也不会报错
	s.clear（）	情空所有元素
	s.copy()	浅拷贝
	s.pop（）	从集合里随机删除一个元素，如果集合为空，则报keyerror错
	s.update（s1）	用s与s1的并集更新s
	等
	
	集合推导式：
		用可迭代对象生成集合的表达式
		语法：
			{表达式 for 变量 in 可迭代对象 [if 真值表达式]}
			
	固定集合 frozenset：
		无序的不可变的，不含重复元素的集合
		作用：可以作为字典的键，还可以作为集合的值
		创建：fs=frozenset（）
		创建非空：fs=frozenset（iterable）
		固定集合的方法:
			相当于集合的全部方法，去掉可以修改集合的方法

	列表/字典/集合的对比区别：
		1.都为可变的
		2.列表尾部插入速度比较快，但中间和头部插入慢
		3.列表有序
		4.字典的添加删除修改速度快于列表
		5.集合的添加和删除速度快于列表，但不能存重复元素

	频繁的插入删除用字典和列表，尾插如果数据有顺序用列表
	集合可以去除重复的元素
	python3中推导式的种类：
		列表推导式，字典推导式，集合推导式


函数 function
	
	定义：	def 函数名（参数列表）:
			函数体
		注：1.函数名为一个变量
		    2.如果没有return语句则返回时会返回None对象
		    3.如果函数体为空，则需要填充pass
		return语句格式：
			return[表达式] 			#表达式部分可以省略
			注：一个函数体内的return语句可以有多个但是一旦一个return执行，其他将不再执行
python参数传递方式（调用函数时）：
	传递方式：
		  位置传参（实际调用时的实参与函数定义时形参的位置对应），序列传参，关键字传参，字典关键字传参
		  序列传参的示例：
			def dx（a,b,c）
			   print("a")
			   print("b")
			   print("c")
			L=[1,2,3]
			dx(*L)	#拆解序列，依次传参。拆解L将对应位置的值传递给对应形参。利用了序列传递参数，当然也可以用列表索引用位置对应来传递参数
		  关键字传参：
			传参时，按形参的名字给形参赋值
			例子：	def dx（a,b,c）
				    pass
				dx（a=1，c=2，b=3）	#调用，传参。一一对应传参
		  字典传参：
			实参为字典，用**拆解字典后再按关键字传参
		  	示例：
				def dx（a,b,c）
				    pass
				d={"a"=1,"c"=2,"b"=3}
				dx(**d)		#字典传参。拆解字典，关键字对应传参，传递a=1，b=3，c=2
		  综合传递参数：以上几种，可以在调用传递参数时综合使用。但位置和序列传参一定要先传递，否则出错。
函数的缺省参数：
	语法：
		def 函数名（形参名1=默认实参1，形参名2=默认实参2，...）
			函数体
	相当于在函数定义时，就给形参一个默认值，如果在实参传递是没有给形参一个值，那么函数调用将会用默认值
	注意：缺省参数必须从右至左依次存在。缺省参数可以至少有0个。
	
	q缺省形参列表的生命周期：
	def AdList(a,list_=[]):
	list_.append(a)
	print(list_)
	AdList(1)	#[1]
	AdList(2)	#[1,2]
		
函数的形参定义方式（定义函数时）：
	1.位置形参：最常用，最常见的，最熟悉的那种
		def 函数名（形参1，形参2）：
			函数体
	2.星号元组形参（接受数据形成序列）
		def 函数名（*元组形参名）：
		作用：调用时，接受任意类型的实参，实参列表里面的统一存放于一个元组，函数内部通过操作元组来操作实参。
		例子：
			def func（*args）:		#args为元组
				print("实参个数是",len（args）)		
				print（“args的值是：”，args）		#（1,2,3）
			func（1,2，3,）	#调用	实参个数是3	args的值是（1,2，3）
	3.命名关键字形参（调用时尾部需进行关键字传参）	
		语法：	def 函数名（*,命名关键字形参）：
				函数体		
			或 def 函数名（*args，命名关键字形参）
				函数体
		作用：所有的命名关键字形参都强制调用者采用关键字传参或者字典关键字传参方式调用
		例子:
			def func(a,*,b)			 # *号相当于一个分隔符，星号右边的参数表示在调用时必须按照命名关键字进行传参
				print("a=",a)
				print("b="，b)
			调用:func(100，b=200）		#b强制进行关键字传参
				
			def func2(b,*args,c,d)
				print("a=",a)
				print("*args=",args)
				print("c=",c)
				print("d=",d)
			调用：func2（100,2,3，4,c=500，d=600）	#2,3,4给了元组args。用到了位置形参，星号元组形参，及命名关键字形参
	4.双星号字典形参（接受数据形成字典）
		语法：
			def 函数名（**字典形参名）：
				函数体
		作用:
			 收集多余的关键字传参
		示例：	
			def func（**kwargs）：
				print（“个数为：”，len（kwargs））
				print（“值为”，kwargs）
		调用:	func("name"="Jake",age=10)	#相当于将实参列表内的所有关键字传参一并生成到kwargs字典内
	
函数形参说明：位置形参，星号元组形参，命名关键字形参，双星号字典形参，缺省参数都可以混合使用		
函数参数从左至右的顺序为：位置形参，星号元组形参，命名关键字形参，双星号字典形参
示例：
	def myfunc（a，b，*args，c，**kwargs）
		print（a，b，args，c，kwargs）
	调用：myfunc（1,2,3,4，*"AB"，c=6，**{'d':'D'}）
可以接受任意位置传参和关键字传参的函数：
	def func（*args，**kwargs）
	    pass


要点小结：		
位置传参，关键字传参（对应关键字传参），序列传参（拆解序列），字典传参（拆解字典）
位置形参，星号元组形参（形成元组），命名关键字形参（自动合并输入写入到元组，且后部需为关键字传参），双星号字典传参（形成字典）


函数作为参数传递：传递函数名。
函数名相当于一个指针，绑定的是def定义的函数对象

函数可以返回另一个函数：根据需要返回要使用的函数名

函数嵌套定义:函数可以创建在一个函数的内部，这样就可以动态地调用	

全局和局部变量：
	函数内部为局部变量，调用时创建，用完后自动销毁，作用于只在函数内部。
	函数外部，模块内部为全局。函数内部无法修改全局变量的绑定关系
	尽量少用全局变量。多用函数
作用域：命名空间，访问变量时查找变量名的范围空间
	局部（函数内）
	模块作用域(全局）
	外部嵌套函数作用域（闭包）
	python内置模块作用域

变量名查找规则：
	L（local）--》E(闭包函数)---->G(模块内部)-----》B（内建模块）
	函数内部变量不能影响外部变量，内部无法影响外部变量。当在多层嵌套里面，这条规则尤为有用。

两个关于变量的函数：locals/globals
	返回局部/全局变量的变量的字典

global语句：
	语法：global 变量1，变量2...
	含义：指定一个变量为全局的变量，其作用域为模块级。会将赋值变量映射到模块文件内部的作用域
	注意：global需先声明才可赋值。函数内部可以直接访问全局变量。

nonlocal语句：	
	作用：声明的是外部函数嵌套的变量，相当于闭包的变量。一旦声明则操作的是外部嵌套函数的变量
	语法：nonlocal 变量名1,....
	说明:当有两层或两层以上的函数嵌套时，访问nonlocal变量只对最近的一层的nonlocal进行操作、
	     nonlocal语句的变量列表的变量名，不能出现在此函数的参数列表里
	
Lambda表达式：（匿名函数表达式）
	作用：创建匿名函数对象，没有函数名，相当于一个简单的函数，用变量绑定。只有一条语句的函数可以用lambda代替
	语法：Lambda [形参1，...] : 表达式
	例子:	m=Lambda x,y : x+y	#绑定的函数就相当于一个函数，调用按照def定义的函数一样的模式调用
	说明：它是个表达式，用于创建函数对象。
	      调用时，先执行冒号后的表达式，并返回一个表达式的结果的引用
	      其创建的函数只能包含一条表达式
	      比函数简单，随时创建和销毁，有利于减少程序的耦合度

eval和exec函数：(express value ，execute）
	eval可以把一个字符串当成表达式执行，返回执行后的结果
	exec把一个字符串当成程序执行
	
函数式编程：
	指用一系列函数解决问题	
	1.函数本身是对象，可以赋值给变量
	2.函数可以作为实参
	3.允许函数返回函数
函数式编程好处：
	可以将大问题拆成小的，再一一解决
高阶函数：
	（满足以下之一即为高阶函数）
	函数接收一个或多个函数作为参数传入
	函数返回一个函数
pyhton内置高阶函数：
	map，filter，sorted
	map（func，*iterable）用iterable可迭代对象，生成新的可迭代对象
	示例：
		def power（x）:
		   return x**2

		for x in map（power,range(1,10)）
			print(x)	#1,4,9,...,81
filter函数：
	filter（func，iterable）
	筛选可迭代对象中的数据，返回一个可迭代对象
	函数func对iterable中所有数据进行求值，返回false时将此数据丢弃，反之保留
	func自己实现
sorted函数：
	将原可迭代对象数据进行排序，生成排序后的列表
	sorted（iterable，key=None，reverse=False）
	key绑定函数，此函数提供排序规则
	例子：		[5，-1,2,，-3，-4,0]若按照绝对值大小来排序，可以设置key=abs函数

递归函数：（recursion）
	函数直接或间接调用自身
	说明：递归一定要有控制递归终止的条件，即递归条件
	      递归深度不可过大，否则会得到不可预知的结果
	      每次调用函数时，则会重新开辟一块函数空间
	      return会依次回到上一层递归调用
	案例：经典递归求和，列表的变量，文件夹的递归
		def MySum（x）：
			if x==1：
			   return 1
			return x+MySum（x-1）

		
闭包：（closure）	“大包用绳子系着一个小包”
	将内嵌函数的语句和这些语句的执行环境打包在一起后得到的对象称为闭包
	闭包必须满足的条件：
		1.必须有一个内嵌函数
		2.内嵌函数必须引用外部函数的变量
		3.外部函数返回值必须是内嵌函数
	原理：创建外部变量且外部函数返回后，环境（外部变量）不会被释放且与嵌套函数捆绑一起
	示例：
		def make_power（y）：
			def fn（x）：
			    return x**y
			return fn
		pow2=make_power（2）
		print（“5的平方时:”,pow2(5)）
	说明：在闭包中，局部变量y本应该被销毁但并没有，在外层函数返回时，将y与内嵌函数
	      绑定在了一起，因此y并没有随着外层函数的返回而被销毁  
	优点：1.创建功能类似的函数方便，比如上面可以创建4次方以及5次方等等
	     
装饰器（decorators）：（其实装饰器就是用闭包函数实现的）
	
	装饰器是一个函数，作用是包装另一个函数或类。目的是在不改变原函数名的情况下改变被包装对象的行为
	函数装饰器:装饰器是一个函数，传入一个函数，返回也是个函数
	说明：外部函数传入被装饰函数名，内部函数返回装饰函数名。
	      一个函数可以有多个函数装饰器来装饰。一层一层装饰	
	特点：1.不修改被装饰函数的调用方式 2.不修改被装饰函数的源代码
	示例：
		# 装饰器函数
		def Decoration_func(fx):
    			def print_hello():
        		   print("hello world")
    		 	return print_hello


		# 函数装饰器，作用相当于重写下面的Hello函数。等同于 Hello=Decration_func(Hello)
		@Decoration_func 
		# 被装饰函数
		def Hello():
    		print("hello ran")


		# 打印hello world，作用相当于重写了hello
		Hello()	
	
	示例2：	
		def Decor_func2(fx):
    			def InerFunc():
       			   print("我装饰了原函数")
        		   fx()	# 调用了原函数
        		   print("原函数已经被调用了")
     			 return InerFunc


		@Decor_func2  # 等同于 formal_func=Decor_func2(formal_func)
		def formal_func():
    		   print("我是原函数！")
	

		formal_func()	# 调用了InerFunc（），而fx此时绑定的是原函数，原函数的名字绑定的是InerFunc

	应用场景：
		不改变原函数的情况下，增加或者修改部分功能。

函数的文档字符串：
	语法：
		def 函数名（参数列表）
		    """函数的文档字符串"""
		    函数语句块
	说明：
		文档字符串通常用于说明本函数的功能和使用方法
		在交互模式下，输入help（函数名）即可查看文档字符串

函数的_doc_属性：
	函数内第一次未赋值给任何变量的字符串是此函数的文档字符串
	此字符串会自动赋值给函数的_doc_属性
	示例：
		def cba（）：
		   '这是一个文档字符串'
		    pass
		print（cba._doc_）	
函数定义的完整语法：
	[decorator1]
	[decorator2]
	[    ...   ]
	def 函数名（位置形参，*元组形参，命名关键字形参，**字典形参）：
		"""函数说明，文档字符串"""
		函数体
————————————————————————————————
模块 module

	含义：包含类，函数，变量等组成的程序组。
	      是一个文件，通常以.py结尾
	作用：  让相关变量，函数，类有逻辑地组织在一起，使得逻辑更加清晰
	        模块之间可以相互调用
	分类：  内置模块（biultins），在解释器内部可以直接使用（C语言的）
		标准库模块，安装python时已安装且可直接使用
		第三方模块（通常为开源），需要自己安装
		用户直接编写的模块
	
模块的导入 import
	作用：导入第三方模块到当前模块 
	例如：import os,math [as 取的新名]
	查看模块内成员：help（模块名）		#可以查看模块内函数变量等
	
	from module import 模块属性名,... [as 新名字]	#用于导入模块中的某个或某几个成员
	from module import *	#导入模块中全部成员，这样导入后不用以 模块.成员 的形式调用模块内的成员
				 可以以 函数成员() 的形式调用模块内的函数。但是注意当前模块中是否有与导入的
				  模块中的成员重名，尽量少用 import *

导入模块时的路径索引顺序：
	1.索引程序的运行时路径
	2.搜索sys.path里提供的路径
	3.搜索内置模块

模块化编程好处：
	利用多人合作开发
	代码易维护
	提高代码复用率
	有利于解决函数名和变量名重名问题

自定义模块：
	主模块和自定义需要调用的模块需要在一个文件夹目录内，否则调用不了
	如果能把自己的模块写在sys.path的搜索路径内，list.append（）追加

模块加载过程：
	1.导入时，模块所有语句都会执行
	2.若一个模块已经被导入一次，则再次导入时模块内的语句不会被执行第二次
	
模块的重新加载：
	import imp
	imp.reload（module）	#module事先已经被加载过一次

模块被导入和执行的过程：
	1.先搜索相关路径，找到.py文件
	2.判断是否有此模块的.pyc文件，则用.py文件生成一个再进行加载
	3.若已存在，则判断.pyc文件和.py文件的修改时间，再决定是否重新生成.pyc文件。（若py文件被修改需要重新编译）
	注意：pyc文件是编译过后的文件，再解释执行pyc文件。

dir函数：
		
	格式：	dir[对象]  -> 返回一个字符串列表
	说明：
		没有参数调用时  ->  返回当前作用域内所有变量的列表
		给定一个对象作为参数时  ->  返回该对象的所有变量的列表
		1.对于模块，返回这个模块的全部属性
		2.对于一个类对象，返回类对象的所有变量，并递归基类对象的所有属性
		3.对于其他对象，返回所有变量，类变量和基类变量
		
内置模块math
	变量：
		math.e	#自然对数的底
		math.pi #圆周率pi
	函数名：
		.ceil（x）	向上取整
		.floor（x）	向下取整
		.sqrt（x）	返回x的平方根
		.factorial（x）	阶乘
		.log（x[,base]）返回以base为底x的对数，如不给base则以自然对数e为底
		.log10（x）
		.pow（x，y）	x**y
		.fabs（x）	浮点数x的绝对值
	角度和弧度的转换：
		.degree（x）	弧度转换为角度
		.radians（x）	角度转换为弧度
	三角函数：
		.sin（x）	返回x的正弦
		.cos（x）		
		.tan（x）	
		.asin（x）	x的反三角函数正弦
		.acos（x）	
		.atan（x）
时间模块：
	导入：import time
	公元元年（0000），对unix或是linux的计算机元年是1970年1月1日0时开始的
	UTC时间：通用坐标时间，全世界统一的时间。伦敦时间
	DST（夏令时）
	时间元组：      九个整形元素组成的
			四位的年（如 1993）
			月（1-12）
			日（1-31）
			时（0-23）
			分（0-59）
			秒（0-59）
			星期（0-6）
			元旦开始日（1-366）
			夏令时修正时间（-1,0 or 1）
			注：如果年份小于100，会自动加上1900的值
			    gmtime（），localtime（）返回的，mktime（）传入的
	变量：
		time.altzone	夏令时与UTC时间差 单位为秒
		time.daylight	夏令时校正时间	对于中国为0
		time.timezone	本地时间与UTC时间差，秒为单位
		time.tzname	时区名字的元组，第一个名字为未经夏令时修正
		注：CST（china 	standard time UTC+8：00）

	函数：
		time.time（）	 	返回从计算机元年到当前时间的秒数的浮点数（UTC时间为准）
		time.sleep（secs）	让程序在给定的时间段内沉睡，单位秒

		time.gtime([secs])	将给定的秒数转化为UTC表达的时间元组，以1970年为基点
		time.localtime（[secs]）将UTC秒数时间转换为日期元组，以本地时间为准

		time.asctime（[tuple]）	给定时间元组，转化为美式日期时间字符串
		time.mktime（tuple）	将本地日期时间元组转化为新纪元秒数时间（UTC为准）
		时间元组格式：九个数据，元组内的数据类型为int

系统模块 sys ：
	运行时系统相关的信息和函数
	变量：
		sys.path	模块搜索路径path[0]是当前脚本程序的路径名，否则为空字符串""
		.module		已加载模块的字典
		.version	版本信息字符串
		.version_info	版本信息的命名元组
		.platform	当前运行的系统
		.argv		命令行参数，argv[0]当前脚本程序路径名
		.copyright	python版权相关信息
		.builtin_module_name	获取内建模块的所有名字
	方法：
		sys.exit（）		遇到该语句，则程序直接结束
		.getrecursionlimit（）	得到递归嵌套层次限制（栈的深度），默认1000，最多执行1000次
		.setrecursionlimit（n）	得到和修改嵌套层次限制（栈的深度）


标准库模块 random：
	作用：模拟生成随机数的模块
	random.random()			返回一个[0,1)中的一个随机数
	.uniform（a,b）			[a，b）内的随机数
	.randrange（a，b，step）	返回其内的一个随机整数
	.choice（seq）			从序列中返回随机的元素
	.shuffle（seq[,random]）	随机指定序列的顺序，打乱列表
	.sample（seq，n）		从序列中随机选择n个随机不重复的元素 	
			

模块的文档字符串：
	模块内第一行没有赋值给任何任何变量的字符串，通常绑定在_doc_属性上
	__file__属性：绑定了模块对应的文路径位置
	__name__属性:用于记录模块自身的名字。
		作用：1.记录模块名字 2.用于判断是否为主模块
		说明：主模块的__name__属性绑定的是__main__，主模块为当前第一个运行的模块，一般就是自己正在写代码的模块
		      当此模块不是主模块时，模块为文件名去掉.py。现有A模块，在A模块中importB模块，A是主模块，B非主模块，A的__name__属性为__main__
	
	__all__列表：
		用于存放可导出属性的字符串列表，可以在自己的程序中加入该列表，限制别人使用功能
		作用：
			当用from module import *时，只导入__all__内的属性
模块的隐藏属性：
	模块中以下划线开头的属性，在from import * 语句导入时，将不会导入，称这些为隐藏属性
	作用：限制导入


包（模块包）package
	包是将模块以文件夹的形式进行分组管理的办法。一个包下可以有若干个文件夹，而每个文件夹内可以有若干个py文件
	作用：  1.模块分类管理，防止命名冲突
		2.可以在需要时加载一个或者几个模块，而不是所有
	导入语法：
		import 包名 [as 包别名]
		import 包名.模块名 [as 模块别名]
		import 包名.子包名.模块名 [as 别名]
		from 包 import 模块 
		form 包.子包.模块 import 属性名 as 别名	
		等等
	__init__说明：每个本地包的根目录下，必须有一个__init__.py 否则解释器不认为是个包，导入时会被自动调用
	      	      在其内部可添加包的文档字符串
	              在其内部可以加载此包所依赖的其他模块(即在__init__里import其他的模块)
		      甚至可以在其内部编写代码
		      在加载包时，只有__init__被加载
	__all__说明：
			作用：记录包中哪些子包或模块需要导入
			      当用from import *时，只查找__all__列表中的，可以控制导入的模块有哪些
			      __all__列表写在__init__.py文件内
			注意：当子包或子包内的模块被导入时，上一层的包也会被先导入
			      例如：import mypackages.games.contra    ，会先导入mypackage，依次导入到最后一层包
	包的相对导入：
		指包内模块的相互导入
		语法：	
			form 相对路径包或模块 import 属性或模块名
			from 相对路径包或模块 import *
		相对路径指：
			.代表当前目录+包名或模块名
			..代表上一级目录
			...上二级目录
		注意：
			相对导入时不能超出包的外部
			导入要避免循环导入（两个包不能互相导入）

异常 （基础） excption
	1错误：由于 逻辑或语法不当 而导致程序错误而结束运行结束
	2python异常：
		程序出错时标识的一种状态
		当异常发生时，程序不再往下执行，为了保持福你那里有程序的健壮性，需要捕获相应的异常。
		产生异常就说明某处发生了错误，且需要去处理
	3try语句：
		try-except：（至少一个except，else可省略，finally也可省略）
			try：
			    可能发生异常的语句块
			except 错误类型1 [as 变量1]：
			       异常处理语句1
			...
			except 错误类型n [as 变量n]：
				异常处理语句n
			except：
				统一处理任何出现的错误
			else：
				未发生异常时执行的语句
			finally：
				最终语句	
		
		作用：尝试捕获异常（如果异常产生），则用except来处理异常，使程序继续运行下去，不至于崩溃。
		      没有产生异常时，except子句是不会执行的
		      多个except错误类型时，依次向下寻找匹配。
		      except ：		可以处理任何错误
		      else子句只在没有发生异常时执行，发生错误时是不会执行的。
		      finally子句，任何情况下都会执行	
		异常类型：
			  valueError（值错误，传入无效参数），ZeroDivisionError（零作为分母而产生的错误），
			  AssertionError（断言语句失败），StopIteration(迭代器没有更多的值)
			  IndexError（序列中没有此索引），IndentationError（缩进错误）
			  IOError（输入输出操作失败）	，ImportError（导入模块/对象失败）
			  NameError(未声明/初始化对象)	，AttributeError（对象没有这个属性）
			  BaseException（所有异常基类）	，SystemExit（解释器请求退出）
			  KeyboardInterrupt（用户中断执行，通常是输入^c）
			  Exception（常规错误基类）	，GeneratorExit（生成器发生异常来通知退出）
			  StandardError（所有内建标准异常的基类）
			  ArithmeticError（所有数值计算错误的基类）
			  FloatingPointError（浮点计算错误）
			  OverflowError（数值运算超出最大限制）
			  EOFError（没有内建输入，达到EOF标记）
			  EvironmentError（操作系统错误的基类）
			  OSError（操作系统错误） 
			  WindowsError（系统调用错误）
			  
		说明：
			as可以省略，绑定错误对象的变量
			except子句可以只有一个或者也可以有多个
			else子句最多一个，也可以省略
			finally子句最多只有一个，也可省略
try-finally 语句
	try：	
		可能触发异常的语句
	finally：
		最终语句
	说明：
		不存在except，finally必须存在
	用途
		无论是否发生异常，一定要做的事情
raise语句：
	作用:触发一个错误，让程序进入异常状态。可以使用raise主动抛出异常，可以用try-except语句捕捉它处理它。
	语法：
	    raise  异常类型
	或  raise  异常对象
	例子：
		raise ValueError（"描述信息"） 		#描述信息交给变量e
		处理时可：
			except ValueError as e :
				print（"错误的值是：",e）		#e绑定错误信息
assert语句（断言语句）：
	语法：
		assert 真值表达式，错误数据（通常是字符串）
	作用：
		当真值表达式为False时，用错误数据创建一个AssertionError类型的错误，并进入异常状态
	等同于：	
		if 真值表达式 == False：
		   raise AssertionError（错误数据）

为什么要用异常处理机制：
	在程序调用层次较深时，错误信息要层层传递给上级调用者，一直return会很麻烦。所以用异常处理机制很方便
	异常机制是：只要异常没被处理，异常就会自动逐级向上传递，直到遇到处理异常的except。



迭代器(Iterator) 和 生成器（Generator）:

	什么是迭代器：
		是访问可迭代对象的一种方式，用迭代器可访问可迭代对象
		迭代器是iter（可迭代对象）返回的对象
		迭代器可以用next（it）函数获取可迭代对象的数据
	迭代器函数：
		iter（iterable）	从可迭代对象中返回一个迭代器，iterable必须是能提供一个迭代器的对象
		next（iterator）	从迭代器iterator中获取下一个记录，如果无法获取下一个记录，则触发StopIteration异常
	迭代器说明：
		迭代器只能往前取值，不会后退(不能重复取值)
		用iter函数可以返回一个可迭代对象的迭代器
		
	示例：
		L=[1,2，3,4]
		iterator=iter（L）
		next（iterator） 	#1
		next（iterator）	#2	
		next（iterator）	#3
		next（iterator）	#4
		next（iterator）	#StopIteration
	说明：其实for in 语句也是用可迭代对象生成一个迭代器，然后用迭代器来访问可迭代对象
	 	L=[1,2，3,4]
		访问方式1：	for x in L：
				   print（x）
		访问方式2：
			try：
			    it=iter（L）
			    while True：
			        x=next（it）
			except StopIteration：
				break


生成器 generator（2.5版本以后）	：
	定义：能动态提供数据的对象，生成器也是可迭代对象
	种类：  生成器函数和生成器表达式
		生成器函数：
			定义：含有yield（翻译为产生）语句的函数时生成器函数，此函数被调用将返回一个生成器对象
		              yield语句：
					语法：yield 表达式
				        说明：yield语句用于def函数中，目的是将此函数作为生成器函数使用
					      yield用于生成数据，供next（it）使用
					      返回一个生成器对象，也是一个可迭代对象，返回的该对象可以用for in 遍历
	例子：
		def myyield（）：
		    print("产生2")
		    yield 2	
		    print（"产生3）
		    yield 3

		gen=myyield()	#gen绑定生成器，是一个生成器。也是一个可迭代对象
		it=iter（gen）  #it为迭代器
		next（it）	#利用迭代器访问生成器对象。打印"产生2"，生成2。函数阻塞在yield 2 处

	生成器表达式：
		语句：
			（表达式 for 变量 in 可迭代对象 [if 真值表达式]）
		作用：
			用推导式形式，生成一个新的生成器
	迭代工具函数：
		用于生成一个个性化的可迭代对象（可是生成器）
		zip（iter1[,itera2，...]）返回zip对象，zip对象是利用传入的可迭代对象生成元组。该元组有iter1和itera2等
					  组合而来。元组个数以最短的可跌打对象觉得
		例子：
			nubers=[10086,10000,10010,97743]
			name=["中国移动","中国电信","中国联通"]
			for t in zip（numbers,name）
				print（t）	# (10086,"中国移动")  （10000，"中国电信"）  （10010，"中国联通"）
		自己实现zip：
			def myzip（iter1，iter2）：
				it1=iter（iter1）
				it2=iter（iter2）
				while True：
					yeild （next（it1），next（it2））
		enumerate（iterable[,start]） 将为iterable每个值加一个索引，返回元组。索引默认为0开始，可设定	
		例子：
			name=[“小王”，“小张”，“小李”]
			for t in enumerate（name）
				print（t）	#(0,“小王”)	(1,“小张”) 	(2,“小李”)
字节串和字节数组：
	字节串（或字节数组） bytes
	作用：
		存储以字节为单位的数据，这个容器里面只能存字节
	说明：
		不可改变的序列
		字节是0-255的整数
		字节说明：'A' --》 0x41 --》 0100 0001（8个位，一字节） 8bit=1Byte
			  100M bps（bytes per second） 1 0000 0000位每秒
			  存储的最小单位是字节Byte，数据的最小单位是bit，一个字节能表示的最大数为255，最小为0


	创建空字节串：
		B = b''
		B = b""	
		B = b''''''
		B = b""""""
	创建非空：
		在引号里面加入东西。加的东西只能是英文数字等，不能放汉字

	字节串的构造函数：
		bytes()				生成空字节串，等同于b''
		bytes（整数可迭代对象）		可可迭代对象生成一个字节串
		bytes（整数n）			生成n个值为0的字节串
		bytes（字符串,encoding='UTF-8'）
		用于生成字节串
	字节串的运算：
		+ += * *=
		< <= > >= == !=
		in / not in
		索引和切片
	相关函数：
		len，max，min，sum，any，all
		详见：help（bytes）
	字节串与字符串的区别：
		bytes存储字节（0-255）
		str存储字符（Unicode值）
	bytes与str的转换：
		编码encode 	str---------->bytes
			b = s.encoding(encoding='utf-8')
		解码decode	bytes-------->str
			s=b.decode(encoding='utf-8')

字节数组（可变的字节串）
	bytearray（）		创建空串
	bytearray（整数）	
	bytearray（整型可迭代对象）
	bytearray（字符串，encoding='utf-8'）
	操作：
		+ += * *=
		> >= < <= == !=
		in / not in
		索引与切片，规则与列表的相同
	方法：
		.clear（）		清空字节数组
		.append（）		追加一个字节（0-255）
		.remove（value）	删除第一个出现的字节，若没有出现则引发ValueRrror错误
		.reverse（）		字节顺序反转
		.decode（encoding='utf-8'）	将字节数组转换为字符串
		.find（sub[,start[,end]]）	查找sub子字节数组

文件：
	什么是文件
		存储数据的单位
		用于长期存储
		以字节为单位进行顺序存储
	文件操作：打开，读写，关闭
	文件打开函数 open：
		fileobj=open（file,mode='rt'）		file为文件路径，返回此文件的文件流对象，如果打开失败会触发IORrror错误
							mode：'r'只读，默认
							      'w'只写，删除原有文件内容，如果原文件不存在则创建
							      'x'创建新文件并以写模式打开（若存在文件则引发异常）
							      'a'只写打开一个文件，如有原文件则追加到末尾
							      'b'以二进制模式打开
							      't'文本模式打开		
							      '+'为更新内容打开一个磁盘文件（可读可写）
							缺省模式是'rt'
							'w+b'可以实现二进制随机读写，当打开文件时，文件内容将被清零
							'r+b'二进制读和更新模式打开文件，打开文件不会清零文件
							'r+'文本模式读和更新文件，不会清除文件内容
								
	文件关闭函数 close（）				关闭文件，释放系统资源
	方法：
		F.readline（）				读取一行，返回相应字符串，一行只读取依次，到末尾后为空串。
		F.readlines（max_chars=-1）		返回每行字符串的列表
		F.writelines（lines）			每行字符串的列表
		F.flush（）				把写入到对象的缓冲区内容写到磁盘
		F.read（size=-1）			从文件流对象中读取size个字符
		F.write（text）				写一个字符串到文件流

	文件操作：
		文本文件操作和二进制文件操作
			文本文件模式：
				mode='t'	1.文本文件内为字符数据，以行为单位读取，采用系统默认换行符进行分隔
						2.文本文件的读取写入需用字符串进行操作（str）
						3.各操作系统的默认换行符：Linux为\n，Windows为\r\n，新的Mac OS为\n
			
		
		二进制文件操作：
			打开模式：'b'
			文件中存储的都是以字节为单位的二进制的数据，以字节为单位进行读写		
			对二进制文件的读写需要以字节串（bytes）进行操作
			方法：
				open（）
				F.read（）	读取文件流字节
				下两个方法针对二进制文件
				F.tell（）	返回文件流的绝对路径
				F.seek（offset，whence=0）	改变数据流的位置，可以指定文件流读取的位置（比如从中间开始读取）	
								offset：大于0向文件末尾移动，小于0向文件头移动
								whence：0代表从文件头开始偏移
									1从当前位置开始偏移
									2从文件尾开始偏移
				F.readable（）		判断文件是否可读，返回布尔值
				F.writeable（）		判断文件是否可写，返回布尔值
				F.seekable（）		判断文件对象是否支持随机定位(seek)
				F.truncate（pos=None）		剪掉pos之后的数据，返回新的数据对象
汉字编码：
	国标系列 GB18030（2字节或4字节编码，共27533个）
		 GBK(2字节编码，21003个)
		 GB2312(2字节编码，共6763个）
		 （常用于Windows）
	国际标准：
		 UNICODE16UNICODE32 <----> UTF-8（中文字在utf8下是三个字节，Unicode和utf-8可以实现互相转换 ）
		 （常用于Linux，ios，Mac OS X Android）
	编码字符串：用于编码和解码中，实现不同编码的转换
		'gb2312'
		'gbk'
		'gb18030'
		'utf-8'
		'ascii'（全英文编码）
	编码注释:
		 在源文件的第一行或第二行写入如下格式的内容：
		#-*- coding : gbk -*-
		或者#-*- coding : utf-8 -*-
		是告诉python3解释器执行器当前文件的编码是什么 

标准输入输出文件 （Linux中）：
	sys.stdin
	sys.stdout
	sys.stderr	#标准错误输出
	python程序启动后，上面三个已经打开供使用。将内容输出到终端上。
		例子：sys.stdout.write（"你好"）
		      sys.stdin.read（10）	从键盘读取输入10个字符。不加参数则会一直读
						Linux下输入ctrl+d输入结束符
		

———————————————————————	—————
python面向对象：
	大型的程序开发就需要使用面向对象的方法


类 Class与对象 Object
	
	创建：	
		class 类名（继承列表）:
			"""类文档字符串"""
			类变量（class variable）
			静态方法（static method）
			实例方法（类内函数method）
			类方法（class method）
	作用：将一组对象他们的共同特征抽取出来，可以重复使用，是面向对象的基础
	说明：
		类名首字母大写
		类名实质是变量
		类的定义最后要加两个空格，告诉解释器类的定义已经结束
			
				
	构造函数：
		类名（[传参列表]）	
		作用:创建类的实例对象，并返回类的实例对象的引用
	实例说明：
		实例有自己的作用域和名字空间
		通过实例调用类的成员
	实例变量：
		实例自己的变量，或称为属性(比如一条狗的毛发为黄色，黄色就是实例对象的属性)一般是不可变的数据
		首次为属性赋值则创建属性
		再次赋值则改变属性的绑定关系

	属性删除：
		del 对象.属性名
	方法：
		实例方 法:
			def 实例方法名（self，参数1，参数2，...）
				语句块
		实例方法作用：对象的行为
		实例方法说明：为类中的函数；实例方法第一个参数self，代表调用这个方法的实例
			      self相当于C#里面的this。
		实例方法的调用：实例.实例方法名（调用参数） 或 类名.实例方法名（实例对象,调用参数）
				也就是说只能通过实例对象或者类来调用
	
	* 类中的初始化方法：
		作用:对新创建的对象添加属性等必须的数据资源
		语法形式：
			Class 类名：
				def __init__(self,[,参数列表])：
					语句块
		说明：	
			初始化方法名必须为__init__
			初始化方法会在用构造函数创建实例对象后自动调用
			通过第一个参数传入__init__方法
			构造函数的参数将传入__init__的参数列表，用于后续初始化
			初始化方法内如果需要return语句，则必须返回None
		示例：
			Class Car：
			   """小汽车类"""
			   def __init__(self,a,b,c,d):
				self.color = a 	#属性
				self.brand = b
				self.model = m
			   def run(self , speed):
				print(self.color,"的",self.brand,self.model,"正在以",speed,"公里/小时的速度行驶"）
			a4 = Car（'红色','奥迪','A4'）
			a4.run(199)

	析构方法：
		语法：
			Class 类名：
				def __del__(self)：
				     语句块
		作用：
			对象销毁前自动调用，清理对象占用的资源。对象不再被引用时。
			注意：python建议尽量少的在析构方法内做事情，因为销毁时间难以确定。只做释放资源的事
	几个预置的实例属性：
		__dict__属性：绑定一个存储此实例对象自身变量的字典
		__class__属性：绑定创建此实例对象的类
	用于类的几个内置函数： 
		isinstance(obj,class_or_tuple)  返回布尔值，判断某个对象是否是某个类的对象或者某个类中一个类的对象
		type（obj）  返回对象的类
	对象的两大要素：属性和行为方法
	
	类也是一种对象，也可以有自己的属性和方法
	类变量：
		是类的属性，不属于类创建的实例
		说明：1.为变量，可以通过类直接访问
		      2.可以通过类的实例直接访问
		      3.类变量可以通过类的"__Class__"属性直接访问
		示例：
			Class Human：
				totol_count = 0
			print(Human.totol_count)
		注意：实例变量是实例对象专有，而类变量属于类。类变量的修改只能通过类名.类变量来访问修改
		为什么要定义类变量：
			用于存放各个对象所共有的东西	

	类的__slots__属性：
		作用：限定一个类创建的实例只能有固定的属性（实例变量）。规定了实例对象的属性，就不能再随意在类外部添加属性 
		__slots__属性是一个列表，列表的值是字符串
		含义该属性的类所创建的对象没有__dict__字典 
	
	类方法：
		用于操作类的方法，属于类的方法，不属于该类所创建的实例对象
		说明:
			类方法需要使用@classmethod装饰器定义
			类方法的第一个参数用来绑定类，约定为cls
			类和对象实例都可以调用类方法
			类方法不能访问此类创建的对象的属性
		
		示例：
			class A：
			   v = 0  #类变量
				
			   @classmethod
			   def get_v（cls）：
				return cls.v
	静态方法：
		定义在类内部的函数，作用域为类的内部	
		说明：
			使用@staticmethod装饰来定义，类似类方法
			与普通方法定义相同，不需要传入self或cls
			只能用该类或该类的实例来调用
		示例：
			class A:
			   @staticmethod
			   def myadd(a,b):
			       return a+b
			print(A.myadd(100,200))
			a=A()	#实例对象也可以调用
			a.myadd(100,300)
	
面向对象高级特性：
	继承与派生：子类继承自父类，父类派生出子类。可重用的代码放在父类，如果要扩展就是派生
		从已有的类中派生出新的类，新类具有继承类的属性和行为，并能扩展新的能力
	作用：基类具有从它派生而来的类的共同属性或行为，可以提高代码复用率
	      派生类可以保留基类的属性和方法，并且能扩展出自己独有的属性和方法


	单继承：
		语法：
			class 类名（父类名）:
				语句块
		特点：1.子类可以继承父类的方法和属性，如果该父类还继承 自某个基类，那么该子类还会隐式地继承基类的行为方法
		      2.增加代码的复用率
	继承说明：
		python3中任何类都直接或间接继承自object类，object是一切类的超类（类似C#）
	类的__base__属性：
		记录此类的基类


	覆盖（重写）：override
		在有继承派生关系的类中，子类实现了基类（超类）的同名方法，在子类实例调用该方法，则实际是调用的子类重写后的方法
		不会再调用基类方法了。
	当重写发生后，子类对象能否调用父类方法：
		方法一：重写后如果确实还要调用基类同名方法，可以通过：基类.方法名（实例对象， 调用参数）
		方法二：
			super（type,obj）
			返回绑定超类的实例对象，等同于super（__class__,__class实现的对象），且必须在方法内调用。
			作用：返回超类的实例，利用超类实例调用超类方法
		
		实例：	
			class A：
			   def work（self）：
				print（“父类work”）
			class B(A）：
			   def work（self）：
				print（“子类work”）

			   def dowork（self）:
				self.work() 	  	#调用子类work
				super（）.work（）	#调用父类work,放于方法中不用参数
				super（B,self）.work（）#调用父类work，等同于super（__class__,self）.work()
		注意：当子类实现了__init__方法后，父类的将会被覆盖，即创建子类实例对象时，不会主动调用父类的的初始化
		      方法，也即父类相关属性得不到初始化，这时需要在子类中显示地调用父类的初始化方法。
		
	issubclass函数：
		issubclass（cls，class_or_tuple）
		判断一个类是否继承自其他的类，如果此类cls是class或tuple中的一个派生子类，则返回true
		否则返回false	 
		示例：
			class A：
			  pass
			class B(A):
			  pass
			class C(B):
			  pass
			class D(C):
			  pass
			issubclass(B,A)  #

面向对象之封装：
	目的：隐藏类中的实现细节，让使用者看不到细节。让使用者通过尽可能少的使用实例变量名操作对象
	
	私有属性和方法：
		类中以双划线"__"开头，不以双下划线结尾的标识符为私有成员
		私有成员只能被方法调用，不能在子类或在其他地方调用
		种类：私有方法及私有属性
	示例：
		class A：
		  def __init__(self):
			self.__pl=100	#私有属性
		  def text(self):
			print(self.__pl)  #内部可以访问
		  def __text2（self）：	  #私有方法
			pass

	
		  a=A（）
		  a.__pl（）	# 不可以访问，访问出错


面向对象之多态 polymorphic：
	字面意思：多种状态
	多态指在有继承/派生关系的类中，调用基类对象的方法，实际能调用子类覆盖方法的现象叫多态
	说明：多态调用方法与对象相关，不与类相关
	      python的全部对象只有运行时状态（动态语言），没有C++/Java里的编译时状态（静态）
	多态示例： 
		class Shape：
		  def draw（self）：
		     pass
		class Point（Shape）：
		   def draw（self）：
			print（“point draw”）
		class Circle（Point）：
		   def draw（self）：
			print（“circle draw”）
		
		运行时，使用哪个类创建实例就调用哪个实例的方法
	      
面向对象编程语言的特征：
	封装
	继承
	多态
	
面向对象之多继承：
	一个子类继承了两个及以上的基类
	语法：
		class 类名（超类1，超类2,...):
			pass
	作用：可以同时继承多个基类的方法和属性
	缺陷：
		标识符（名字）冲突问题，需谨慎使用，例如：一个AB继承了A类和B类，在A类和B类中有个同名的方法m，当子类
		实例对象调用m方法时，这时就不清楚调用的是A类中的m方法还是B类中的。
	多继承的 MRO（method Resolution Order）问题
		多继承中，子类和基类构成一个“树形”的继承关系，多个类中有同名方法，子类对象在调用方法时，按照
		广度优先的顺序（python2中为深度遍历）依次遍历各个基类节点，调用最先遇到的类中的同名方法
				A   B	  C(m)	D
				 \ /  	   \	/
				  AB(m)	     CD（m）
				    \        /	   
				       ABCD
				o=ABCD()
				o.m()	  #将优先调用AB类中的m方法
		__mro__属性：
			多继承中，实例对象有该属性，该属性为元表，记录着为解决标识符冲突问题提供了具体调用哪个类中
			同名方法的一个各个基类的遍历顺序。
		注意：
			class A:
				pass
			class B:
				psss
			class AB(A,B):		#括号内部的类在mro中在同一深度，A与B有同名方法且子类要
						 调用同名方法时，顺序A优先于B
				pass
			
	函数重写 overwrite：
		定义：在自定义的类中，通过添加特定的方法，让自定义的类生成的实例对象能像内建对象一样进行内建函数操作
		例子：	
			对象转字符串函数重写
			repr（obj）返回一个能代表此对象的字符串（“用字符串表示对象”，便于通信），通常：
				eval（repr(obj）) == obj	
			str(obj)  通过给定的对象返回一个字符串（这个字符串通常是给人阅读的）
			换句话说： 
				repr（obj）返回的字符串是给python用的
				str(obj)返回的字符串是给人看的
		重写方法：
			repr（obj）函数的重写方法	def __repr__(self)
			str(obj)函数的重写方法		def__str__(self)
			当对象没有__str__方法时，则返回__repr__(self)的值
				
		示例str（x）和repr（x）函数的重写方法：
			class MyNum:
			   def __init__(self,value):
				self.data = value
			   def __str__(self):	#重新内建str方法，参数只能是self
				retu rn self.data
			n1=MyNum(100)
			print(str(n1))	#等同于print（n1）
			print(repr(n1)) #调用n1.__repr__（）方法
	内建函数的重写：如果在自定义内中实现了对内建函数的重写，则优先调用重写的函数。
		obj.__abs__()		对应abs(obj)
		obj.__len__()		对应len(obj)
		obj.__reverse__()	对应reversed（obj）
		obj.__round__()		对应round（obj）
		示例：示意abs（）的重写
			class MyInteger：
			      def __init__(self,value):
				  self.data=value
			      def __repr__(self):
				  return 'MyInteger(%d)' % self.data
			I1=MyInteger(-12)
			print(I1)	#等同于str（I1），print内部都会先转为字符串
			I2=abs（I1）	#
			print（I2） 
	数值转换函数重写：涉及将对象转换为特定数值类型
		obj.__complex__()	对应complex（obj）
		obj.__int__()		对应int（obj）
		obj.__float__()		对应float（obj）
		obj.__bool__()		对应bool（obj）			
		示例：
			class MyNumber：
			     def __init__(self,value):
				  self.data = value
			     def __repr__(self):
				  return "MyNuber(%d)" % self.data
			     def __int__(self):		#重写内建函数int
				  return int(self.data)

			n1=MyNumber('100')
			print("n1=",n1)		# MyNumber(100)
			int(n1)			#如果没有重写int会出错，因为int（）只支持整数，布尔类型，
				         	 该类型需要转换的话需自己实现int的重写
			print(float(n1))	#需要实现__float__(self)
	
		布尔测试函数的重写:
			格式：def __bool__(self)：
				   语句块
			作用：  1.用于bool（obj）函数取值
				2.用于if语句真值表达式中
				3.用于while语句真值表达式中
			说明：布尔测试的查找顺序是优先调用__bool__ ,如果没有其次是__len__方法（返回不为0则为true，否则为false）
			      如果没有以上方法则返回true
			示例：
				class MyList：
				"""定义一个容器类，可存储任意类型，其内部的存储方式为list实现"""
					def __init__(self,iterable):
						self.data = [x for x in iterable]
					def __repr__(self):
						return "MyList(%s)" % self.data
					def __bool__（self）:
					 	'''此方法用于bool(obj)函数取值，优先取此函数的返回值
						   规则：所有值为0则为false
						'''
						if sum(self.data):
							return true
						return false
					def __len__(self):
						return len(self.data)


				myl = MyList([1,2,3,4])		
				print(myl)	# "MyList([1,2,3,4])"
				print("bool(mul)=",bool(myl))	
				if myl:
				   print("myl的布尔值为true")
				else：		
				   print（"myl的布尔值为false"）
		注意：总之，函数重写是在自己定义的类中实现，目的是用自定义类创建对象后，
		      又想用类似int（自定义类创建的对象obj）等内建函数，那么就需要重写内建函数，
		      自己定义适应自定义类的规则。这时使用的是重写了内建函数的int（obj）


	迭代器（高级）重写：
		可以通过next（obj）函数取值的对象
		迭代器协议：
			指迭代器无法获得下一项数据时，触发StopIteration异常来终止迭代的约定
		实现方法：
			类内部实现__next__(self)，必须实现没有数据后触发异常,迭代器内部必须有该方法。
			可迭代对象类的内部必须实现__iter__(self)方法
		语法形式：
			class MyIterable:
			     def __next__(self):
				  迭代器协议
				  return 返回数据
		示例：
			class MyList:
    				def __init__(self, lst):
        				self.data = [x for x in lst]

    				# 重写内建函数，使得该对象可以作为迭代器使用
    				def __iter__(self):
        				return next(self.data)	#返回迭代器
			myl = MyList([1, 2, 3])
			# for x in 访问的必须是一个迭代器
			for x in myl:
 			   print(x)

			——————————————

			class MyList：
			  """定义一个容器类，可存储任意类型，其内部的存储方式为list实现"""
				def __init__(self,iterable):
					self.data = [x for x in iterable]
				def __repr__(self):
					return "MyList(%s)" % self.data
				# 可迭代对象内部必须有__iter__方法，但要访问可迭代对象还需有迭代器
				def __iter__(self)：
					"""将MyList对象作为可迭代对象使用，此还方法需返回迭代器"""
					return MyIterator（self.data）	#返回迭代器

			class MyIterator：
			     """自定义迭代器类"""
			     def __init__(self,lst_data):
				  self.data = lst_data	#要访问的数据
			     	  self.cur_pos = 0	#迭代器起始位置
			     # 迭代器对象必须有该方法的实现
			     def __next__（self）:
				  """访问可迭代对象的数据，没有数据则类似内建函数next一样触发StopIteration异常，停止迭代"""
       				if self.cur_pos >= len(self.data):
            				raise StopIteration
       				_index = self.cur_pos
       				self.cur_pos += 1
        			return self.data[_index]：
			myl=MyList([1,2,3])
			for x in myl:
			    print(x)	#1,2,3
								     
	    		注意：__iter__和__next__可以放于一个自定义类中，使得该类的对象既可以当成可迭代对象，又可以当
			     成迭代器使用。
			     
	属性管理函数：
		getattr（obj,name[,defulat]）
		从一个对象得到对象的属性。例如：getattr（x,'y'）相当于x.y
		当属性不存在的时候，如果给出default，则返回默认值。
		如果属性不存在且没有给出default时，则触发AttributeError错误
		hasattr（obj,name）
		判断对象是否有name属性，通常在使用getattr（）之前先用来判断对象的属性是否存在
		setattr（obj,name，value）
		给对象添加为name的属性，并设置属性值为value
		delattr（obj,name）
		删除对象的name属性，delattr（x,'y'）等同于del x.y
		
	异常（高级）：
		with语句：
			语法：with 表达式1 [as 变量名1]，表达式2[as 变量名2]
			作用:在资源访问的场合下使用，不论过程是否发生异常都会执行必要的清理工作，释放资源
			     如文件打开后自动关闭，线程中锁的自动获取和释放
			说明：with语句和try..finally语句很相似，但with并不会变异常状态，用起来也更方便
			      as子句用于绑定表达式创建的对象
			示例：
			      with open（'abc.txt'） as f	#将使用完后自动关闭打开了的文件
	环境管理器：
		类内有__enter__和__exit__方法的类被称为环境管理器
		能够用with进行管理的对象必须是环境管理器
		__enter__将在进入with语句时被调用，并返回由as管理的对象
		__exit__将在离开with语句时被调用，且可以用参数来判断离开with语句时是否出现异常并做出相应处理
		例如：f = open（'abc.txt'）	实现f这个对象的类就有__exit__和__enter__方法，f就是个环境管理器
		
with语句及资源管理器
示例：
#自定义类作为环境管理器
# 演示了with语句，及资源管理器（类中有__exit__和__enter__函数的类）
class FileWriter:
    def __init__(self, fileName):
        self.filename = fileName

    def writeline(self, s):
        """向文件中写入字符串，同时添加自动换行"""
	self.file.write(s)

    def __enter__(self):
        self.file = open(self.filename, 'w')
        print("已进入enter方法")
        return self  # 返回对象绑定as

    def __exit__(self, exec_type, exec_value, exec_tb):
        """
        exec_type 为异常类型，没有异常发生时为None
        exec_value 为异常的值，没有异常时为None
        exec_tb 为错误的traceback对象
        """
	if exec_type == None:
            print("退出with时没有异常")
        else:
            print("退出时有异常，类型是",exec_type,"错误是",exec_value)
	self.file.close()
        print("已经离开with语句，执行了enter")


# 进入with语句，__enter__将自动被调用
try：
  with FileWriter('log.txt') as fw:
    while True:
        s = input("请输入一行：")
        if s == "exit":
            break
        if s == "error":
            raise ValueError("故意制造的值错误")
        fw.writeline(s)  #离开后，__exit__将自动被调用
except：
	print("出现错误，转为正常")

# 此处离开with语句 
	



运算符重载:
	定义：让自定义的类生成的对象能够使用运算符进行操作
	作用：让实例对象像数学表达式一样运算操作；让程序简洁易读
	算术运算符：
		方法名	     运算符
		__add__		+
		__sub__		-
		__mul__		 *
		__truediv__	/
		__floordiv__	//
		__mod__		取余
		__pow__		指数幂

		格式：def __xxx__（self,other）:

	反向运算符重载(在前加个r）：
		__radd__(self, lhs) # 加法 lhs + self
		__rsub__(self, lhs) # 减法 lhs + self
		__rmul__(self, lhs) # 乘法 lhs * self
		__rtruediv__(self, lhs) # 除法 lhs / self
		__rfloordiv__(self, lhs) # 地板除 lhs // self
		__rmod__(self, lhs) # 取模 lhs % self
		__rpow__(self, lhs) # 幂运算 lhs ** self
		
	
	二元运算符重载方法格式：
		__iadd__(self, other) # 加法 self += other
		__isub__(self, other) # 减法 self -= other
		__imul__(self, other) # 乘法 self *= other
		__itruediv__(self, other) # 除法 self /= other
		__ifloordiv__(self, other) # 地板除 self //= other
		__imod__(self, other) # 取模 self %= other
		__ipow__(self, other) # 幂运算 self **= other
		注：当重载后优先使用重载的方法，否则使用__add__等方法代替
	
	比较运算符的重载：
		__lt__		<
		__le__		<=
		__gt__		>
		__ge__		>=
		__eq__		==	
		__ne__		!=
		注意：比较运算符通常返回布尔值
	位运算	符重载：
		__inert__	~ 取反（一元运算符）
		__and__		& 位与（交集）
		__or__		| 位或 （并集）
		__lshift__	<< 左移
		__rshift__	>> 右移
	反向位运算符重载(类似于算术运算符的反向操作)：
		__rand__	& 位与（交集）
		__ror__		| 位或 （并集）
		__xor__		^ 位异或（对称补集） 
		__rlshift__	<< 左移
		__rrshift__	>> 右移
	复合赋值运算符重载：
		__iand__	&= 位与（交集）
		__ior__		|= 位或 （并集）
		__ilshift__	<<= 左移
		__irshift__	>>= 右移
	
	一元运算符的重载：
		__neg__		-
		__pos__		+
		__invert__	按位取反 
	in/not in运算符的重载：
		__contains__(self,e)	#e代表元素
		说明：not in 和in取反
	
		__getitem__
		__setitem__
		__delitem__
	索引和切片运算符的重载：
		假设对象的数据为self.data = [1,2,3,4,5,6,7]
		__getitem__(self,i)	用于索引/切片取值，i是索引下标,i可以是数字对象，也可以是slice对象（如: "::2"）,也可以是字符串对象（键索引）		
					索引：return self.data[i]  
					切片：return self.data[::2]，其中::2代表slice（None,None,2），相当于i拿到的是slice（None，None，2）创建的对象
		__setitem__(self,i，v)	用于索引/切片赋值，i是下标,v是值	索引：self.data[i]=v
		__delitem__(self,i)	用于del语句删除索引操作
		作用：让自定义的类创建的对象能够支持索引/切片操作
		示例：
			def __getitem__(self,i):
				if type（i）is slice:
					print("正在进行切片操作") 
				elif：
					print（"正在进行索引操作"）
				return self.data[i]

		
PEP8编码规范：
	只能4空格缩进
	每行最长为79字节，超过后使用反斜杠折行
	
	import导入模块：按标准、第三方、自定义顺序导入，每导入一个空一行

	关于空格，原则上不加多余的空格



_________________________________MYSQL部分_____________________________

MYSQL01笔记

MYSQL：存储数据的仓库

作用：专门管理数据，提供数据的复杂的操作（增删改查）

哪些公司用：金融机构、游戏网站、购物网站、论坛网站

数据如何储存：前端与后端数据库连接，通过相关接口连接，数据库内部操作数据后，返给前端

提供数据库服务的软件：MYSQL、DB2、MongoDB、SQLSever、Oracle、Mariadb（）

实际中如何选择数据库：
	1.是否开源 开源软件/商业软件
		开源软件不一定免费
		开源：Mysql mariadb Mongodb
		商业：Oracle db2 sql server
	2.是否跨平台：
		不跨平台：sql server
		跨平台：除sql_server
	3.公司类型：
		商业软件：政府部门、金融机构
		开源软件：游戏公司、购物网站等
Mysql特点：
	1.关系型数据库
		数据库由一张张表构成
		表中每一行是一条记录；表中一列为一个字段 
		表与表之间的逻辑关联叫关系
		示例：
		学生信息表
		姓名		年龄		班级
		张三 		20		1班
		李四		23		3班 
		班主任信息表
		班级		班主任
		1班		王麻子
		3班		杰克
	2.非关系型数据库中存储
		{“姓名”：“李四”，“年龄”：25，“班级”：“3班”，“班主任”:“杰克”}

	非关系数据库的性能高于关系型数据库，因为关系型数据库表与表之间查找耗时
	3.mysql为跨平台的数据库，支持多种语言（java，python，php）
	5.关系型数据库的数据存储在硬盘的，而非关系型的为内存。所以关系型数据库的存储速度远小于关系型数据库

mysql安装：
	1.Ubuntu安装：（Redhat，Centos，Ubuntu）
		a.安装服务端： sudo apt-get install mysql-server	（yum -y install mysql-server为redhat，centos下）
		b.安装客户端： sudo apt-get install mysql-client
	2.Windows下安装：
		a.下载安装包安装即可

启动和连接mysql服务：
	1.服务端启动（注意重启服务或者关闭服务需要root权限）
		mysql服务端口为3308
		a.查看mysql服务状态	service mysql status
		b.停止mysql服务		service mysql stop|start|restart|reload
	2.客户端连接
		a.命令格式
		mysql -h主机ip地址 -u用户名 -p密码	如：mysql -hlocalhost -uroot -p123456
							密码无则不写，如果不是连接的本机需要ip地址
							本地连接可以省略-h选项
		
	3.基本SQL命令：
		mysql内部由若干个库组成，每个库内都有若干表
		1.使用规则：    a.每天SQL命令必须以分号;结尾
				b.不区分大小写
				c.使用\c终止SQL命令的执行 
		2.库名的命名规则：
		  	可以使用数字、字母、下划线，但不可使用纯数字
			库名具有唯一性，不能使用特殊字符和Mysql关键字
			库名区分大小写
		3.库命令：
			a.查看已有库： 
			  show databases;	 
			 （查看MySQL服务里的数据库有哪些，库里面存放有表。注意：不能删除mysql自带的库）
			b.创建库（创建库的时候给库指定字符集utf-8才可支持中文）
			  create database 库名（字段列表） default charset=utf8;	  	
			c.查看自己创建的库的字符集
			  show create database 库名;
			d.查看当前所在库
			  select database();	database（）为Mysql自带功能函数
			f.切换库
			  use 库名;
			g.查看库中已有表
			  show tables;
		4.表命令：
			表知识：列名为字段，一行为一条记录
			a.创建表（可以指定字符集）：
				注意：表的charset默认是继承库的，也可以单独指定
				creat table 表名(
				字段名1 数据类型
				字段名2 数据类型
				字段名3 数据类型
				... ...
				）default charset=utf8;
				例如： create table t1(
    						-> name char(20),
    						-> age int ,
   						-> score int );
			     
			b.查看创建表的字符集：
				show create table 表名;
			c.查看表有哪些字段，以及字段的配置属性：
				desc 表名;
			d.删除表:
				drop table 表名;
			e.查看表，类似excel一样的组织方式：
			  	select*from 表名;

		5.注意：Mysql中所有的数据都是以文件的形式存放在数据库目录下
			Ubuntu下数据库目录位置为：/var/lib/mysql

	4.更改库或表的默认字符集（charset）：
		1）方法：通过更改MySQL服务的配置文件
		2）步骤：
			1.获取root权限	sudo -i
			2.切换到配置文件所在的路径  cd /etc/mysql （Ubuntu下）
			3.备份  cp -p my.cnf my.cnf.bak		-p可以连同原文件的权限一起复制
			4.用vi打开my.cnf（也可以用gedit打开） vi my.cnf 或 gedit my.cnf
			  [mysqld]栏，下的tmpdir下加入
			  character_set_server = utf8
			  保存后退出（vim编辑器下，指定位置按a再插入,esc退出插入模式，shift + 冒号进入命令行模式，wq保存并退出）
			5.重启mysql服务  server mysql restart
			6.这时再创建mysql库则其字符集默认都为utf8
			7.退出超级用户root：exit
			8.登录到mysql验证： mysql -rroot -p	rjy
			  		    create database 库名;
					    show database 库名;
	5.表记录管理（为表创建记录）：
		create table t1(name char(20),age int,score int);
		1)在表t1中插入记录
			A.insert into 表名 values (值1),（值2）,...,（值N）;	各个值对应表中的每条记录
			  eg.insert into t1 values("Tom",20,98); 插入单条记录
			     insert into t1 values("Tom",20,98),("Green",21,99);    插入多条记录

			B.insert into 表名（字段名列表）values（值1）,...,（值N）;
			  eg.insert into t1（name,age）values（"Jim",23）;	只为指定的两个字段添加值
		2)查询表记录：
			select * from 表名;				查看所有记录
			select 字段1,[字段2,..,字段N] from 表名;		查看指定字段的值
	6.客户端把数据存储到数据库服务器上的过程：
		a.连接到数据库服务器 		mysql -uroot -p
		b.选择一个库			use 库名;
		c.创建/修改/查询表		create/select等等
		d.断开数据库的连接		exit| quit| \q
	7.名词解释
		a.DB（database）
			存储数据的仓库
		b.DBMS（数据库管理系统）
			如：MySQL，Oracle，MongoDB
		c.DBS（数据库系统）
			DBS = 后端+前端=DB（存储）+ DBMS(管理储存) + 数据库应用 （如：财务管理系统）
	8.数据类型：
		在创建表的时候，指定字段拥有合适的数据类型，对于合理利用存储空间有重要意义
		A.数值类型（有符号signed和无符号usigned，默认为有无符号）
			a.整型
				1.int 大整型（4byte，8bit=1byte，能存42亿多）
				2.tinyint： 微小整型（1byte）
					有符号signed，默认：-128~127
					无符号unsigned：0 ~ 255
					eg.create table t1(id int ,age tinyint unsigned);
				3.smallint 小整数（2字节）
					取值范围：0 ~ 65535
				4.bigint 极大整型（8字节）
					取值范围：0 ~ 2 *	*61 - 1
			b.浮点型		
				1.float（4byte，最多显示七个有效位）
					用法: 字段名 float（m,n） m：表示总位数  n：小数位位数；
					eg.create table t1（salary float（5,2））; 取值范围为：-999.99 ~ 999.99
				2.double（8字节，最多显示15个有效位数）
					用法:	double(m,n)
				4.decimal(M+2个字节，最多显示28位)
					用法：decimal（28,5）
				5.注意：
					a.浮点数插入整数的会自动补上小数位
					b.插入时小数位数多余指定位数时，会自动四舍五入（类似数学算术中的方式）
		B.字符类型
			1.char（定长，1 ~ 255，不给定宽度则默认为1个字符）	
			2.varchar（变长，1~65535，没有默认宽度必须给定宽度）	
			3.char和varchar特点与区别：
				name char（20）不管写入什么数据，都占20个字符，浪费内存空间，但性能更高
				var char（20） 根据数据的实际长度占用空间，而且存入数据的长度，性能较char低
			
		C.枚举类型
			1.定义：只能在列举的范围内选择
			2.enum：单选（最多65535个不同的值）
				用法：字段名 enum（值1，值2，...，值n）
				eg. sex enum（"boy","girl","secret"）
			3.set（...）多选，最多有64分不同的值
				字段名 set（值1，值2，...,值n）
				eg. xingqu set（"c#","c","c++"）
				ps：在插入记录时，用"值1，值2,..."
		    eg.
		     mysql> create table t1(
    			 -> id smallint unsigned,
   			 -> name char(10),
   			 -> age tinyint unsigned,
			 -> sex enum('man','women'),
    			 -> likes set('pingpang','football','tennis')
    			 -> );
		    insert into t1 values(1,"zhang",18,"man","pingpang,football");
		    ps：在插入枚举类型时，需要插入创建表时字段所指定的属性，否则报错。

		D.时间类型
			1.year ：年 	YYYY
			2.date ：日期	YYYYMMDD
			3.time ： 时间	HHMMSS
			4.datetime : 日期时间	YYYYMMDDHHMMSS
			5.timestamp ：日期时间	YYYYMMDDHHMMSS 
			ps:4,5区别是5在插入到表时如果不设值，则默认为系统当前时间
			eg.
			create table t6(
			id int,
			name varchar(10),
			age tinyint unsigned,
			birth_year year,
			birthday date,
			class time,
			meeting datetime)default charset = utf8;
			insert into t1 values(1,"武松",40,1979,19790520,090000,20191002000000);
			eg.2
			mysql> insert into timeTB values(
   		 	-> "zhang san",
   		 	-> 21,
  		 	-> 1994,
 		 	-> 19941012,
   		 	-> 233000,
    		 	-> 19941012233000,
    		 	-> 20191012234322);
			Query OK, 1 row affected (0.04 sec)

			mysql> select *from timeTB;
			+-----------+------+------------+----------------+---------------+---------------------+---------------------+
			| name      | age  | birth_year | birth_year_day | hour_sec_time | meetint_time        | now_time            |
			+-----------+------+------------+----------------+---------------+---------------------+---------------------+
			| zhang san |   21 |       1994 | 1994-10-12     | 23:30:00      | 1994-10-12 23:30:00 | 2019-10-12 23:43:22 |
			+-----------+------+------------+----------------+---------------+---------------------+---------------------+
			1 row in set (0.00 sec)
	9.字段操作：
		语法：alter table 表名 执行动作 操作字段 字段数据类型 [位置参数 first|after];
		A.添加/删除字段：
			alter table 表名 add 字段名 数据类型 [位置参数（默认加在最后一列，如：first）];
			alter table 表名 drop 字段名;
			eg.
			mysql> desc stuInfo;
			+---------+---------------------+------+-----+---------+-------+
			| Field   | Type                | Null | Key | Default | Extra |
			+---------+---------------------+------+-----+---------+-------+
			| id      | int(11)             | YES  |     | NULL    |       |
			| name    | varchar(15)         | YES  |     | NULL    |       |
			| classes | char(7)             | YES  |     | NULL    |       |
			| age     | tinyint(3) unsigned | YES  |     | NULL    |       |
			| height  | float(5,2)          | YES  |     | NULL    |       |
			+---------+---------------------+------+-----+---------+-------+
			5 rows in set (0.00 sec)

			mysql> alter table stuInfo add address varchar(20);
			Query OK, 2 rows affected (0.13 sec)
			Records: 2  Duplicates: 0  Warnings: 0

			mysql> desc stuInfo;
			+---------+---------------------+------+-----+---------+-------+
			| Field   | Type                | Null | Key | Default | Extra |
			+---------+---------------------+------+-----+---------+-------+
			| id      | int(11)             | YES  |     | NULL    |       |
			| name    | varchar(15)         | YES  |     | NULL    |       |
			| classes | char(7)             | YES  |     | NULL    |       |
			| age     | tinyint(3) unsigned | YES  |     | NULL    |       |
			| height  | float(5,2)          | YES  |     | NULL    |       |
			| address | varchar(20)         | YES  |     | NULL    |       |
			+---------+---------------------+------+-----+---------+-------+
			6 rows in set (0.00 sec)
	
		B.修改字段数据类型：
			alter table 表名 modify 字段名 新数据类型;
			注意：在修改数据类型时，会受到表中数据的影响，比如：原来为tinyint，要改为int就会失败
		C.修改字段名：
			alter table 表名 change 旧名 新名 数据类型;
		D.修改表名：
			alter table 表名 rename 新表名;
		
		习题：
			1.Mysql中有几种数据类型：数值型，字符型，枚举类型，日期类型
		
			2.关系型数据库的核心内容是：
			
			3.简述客户端把数据存储到服务器的过程：客户端首先要连接到服务器，要做一些安全验证，针对具体的表进行
							      增删改查的操作，最后断开连接。
			4.char和varchar的区别：char定长类型，耗内存，特点是速度快
					       varchar是变长，根据数据的长度合理使用内存，另外还要存储数据的长度，所以性能就差一些

MySQLday02:
	各实际操作表的例子基于此表：
			mysql> select * from sanguo;
			+------+-----------+--------+--------+-------+---------+
			| id   | name      | gongji | fangyu | sex   | country |
			+------+-----------+--------+--------+-------+---------+
			|    1 | 诸葛亮    |    120 |     20 | man   | 蜀国    |
			|    2 | 司马懿    |    119 |     25 | man   | 魏国    |
			|    3 | 关羽      |    188 |     60 | man   | 蜀国    |
			|    4 | 赵云      |    200 |     66 | man   | 蜀国    |
			|    5 | 孙权      |    100 |     60 | man   | 吴国    |
			|    6 | 貂蝉      |    666 |     10 | woman | 魏国    |
			|    7 | NULL      |   1000 |     99 | man   | 蜀国    |
			|    8 |           |   1005 |     88 | woman | 蜀国    |
			|    9 | 马超      |    130 |     60 | man   | 赵国    |
			+------+-----------+--------+--------+-------+---------+

			
	1.字符类型的宽度和数值类型的宽度的区别：
		数值类型的宽度仅仅为显示宽度，只用于select查询显示，对占用的实际存储空间无关
		字符类型的宽度若超过设定的宽度的话就无法存储	
		eg.	create table t1(id int(3) zerofill)	显示宽度为3位，但实际存储为仍为，不够100用0填充
	
	2.where条件子句（配合查询、修改、删除）：		
		1）查询表记录：select *from 表名 where 条件表达式;
			eg. select name,sex,country from hero where id=1;
			    select name,sex,country from hero where country="吴国";
		2）删除表记录：	delete  from  表名 where 条件;		注意：要加where条件，否则将删除整个表的所有记录
		insert into sangou values
		(1，"诸葛亮",120,20,"man","蜀国"),
		(2,"司马懿",119,25,"man","魏国"),
		(3,"关羽",188,60,"man","蜀国"),
		(4,"赵云",200,66,"man","蜀国"),
		(5,"孙权",110,20,"man","吴国"),
		(6,"貂蝉",666,10,"woman","魏国"),
		(7,NULL,1000,99,"man","蜀国"),
		(8,1005,88,"woman","蜀国");
		
		eg.  delete from hero where id=1;	删除id=1的记录	

		3）更新表记录	
		   UPDATE 表 名称 SET 列名称 = 新值 WHERE 列名称 = 某值
		   注意：一定要添加where条件子句，否则全部将被修改 
		   eg.update hero set country="蜀国" where name="曹操";
			
	3.运算符操作（where）：
		1）数值比较和字符比较
			数值比较：= < <=  > >=  !=
			字符比较：=  !=
			eg.select name,gongji from sanguo where gongji>=150;
			   select *from sanguo  where fangyu<=90;
		2）逻辑比较：
			and	两个或多个同时满足条件
			or	两个或多个有则满足
			注意：嵌套使用时要用括号，否则优先级得不到保障
			eg.select name,gongji from sanguo where gongji>=200 and country="蜀国";
			eg.mysql > select *from sanguo 
   				-> where 
    				-> country="蜀国" or country="魏国";

			where 字段名 in(值1,..,值N)		筛选字段名=值1，及字段名=值N	、			
			where 字段名 not in（值1，...，值N）	筛选出字段名不等于括号中的属性的部分
		
		3)范围内比较：
			1.运算符
				between，and，in，not in
			2.语法：
				between 值1 and 值2	一般值为数值
				in（值1，值2，..,值N）	值可为数字，可为字符串
				not in（值1,...,值N）	同上
				
				eg.查找攻击值在100-200之间的蜀国英雄信息
					mysql > select*from sanguo 
   					     -> where 
    					 -> country="蜀国" and gongji between 100 and 200;

				eg.找到蜀国和吴国以外国家的女英雄信息	
		
					mysql >  select *from
    					     ->  sanguo
    					     ->  where 
    					     ->  sex='woman' and country not in("蜀国","吴国");

				eg.找到编号为1,3,5的蜀国英雄和貂蝉的编号，姓名，国家
					mysql > select id,name,country from sanguo
    					     -> where
    					     -> (id in(1,3,5) and country="蜀国") or name="貂蝉";

		3) 匹配空和非空：
			 空：is null
			非空：is not null
			注意：
				null空值，必须用is /is not匹配，is not null是匹配所有非NULL值的记录，包括""和非空字符串
				""，空字符串，必须用where 字段值=""的形式
			
			eg.查找姓名为NULL的蜀国女英雄信息
			mysql > select * from sanguo
    			     -> where
    			     -> name is null and country ="蜀国" and sex="woman";
			eg.查找姓名为空""的英雄的id，姓名，国家
			   mysql    > select name,country,sex from sanguo
  				   -> where
 				   -> name="";
		4）模糊匹配
			_:匹配一个字符
			%:匹配0到多个字符
			
			eg.select * from sanguo where name like "_%_"	匹配名字至少为两个字符以上的英雄
			   select * from sanguo where name like "%"		匹配名字为空或多个字符的英雄，注意：NULL（空值）不会被匹配
			   select * from sanguo where name like "___"	匹配名字为三个字符的
			   select * from sanguo where name like "赵%"	匹配所有姓赵的英雄

		5）正则表达式匹配查询：非常强大	需要牢记格式语法
			格式：where 字段名 regexp "正则表达式"
			^:  以...开头
			$:  以...结尾
			.： 匹配任意一个字符
			      中文三个字节
			注意：mysql5.7.21中，正则表达式中.匹配的是字节
			      mysql8.0中，正则表达式中点匹配的是字符
			
			[]: 包含...内容，匹配[]号内任意一个。如：[0-9]  匹配数字
								 [a-z]	匹配字母小写	
								 [A-Z]  匹配字母大写
			* :  星号前的字符出现0次或多次	如：^赵.*	以赵开头，后面跟上可以是0个或多个任意字符
			
			
			eg.将name中带有数字的筛选出来
			  mysql  > select name from sanguo
    				-> where 
			        -> name regexp "[0-9]";
			其他例子：
				where name regexp "^[0-9]"	匹配名字以数字开头的记录
			 	where name regexp "[0-9]$"	名字中以数字结尾的
				where name regexp "^司.*懿"	匹配名字司开头，以懿结尾的，中间任意字符
				where name regexp "..."		匹配任意三个字符的名字

		sql查询总结：
		
			完整SQL查询表达式结构：
			select ... 聚合 from 表名
			where ...				先筛选
			group by ...				再分组，再聚合
			having ...				再筛选
			order by ...				再排序
			limit ...				限制查询结果的个数
				

			a.order by
				给查询结果排序
				格式：order by 字段名 排序方式
				排序方式：升序（ASC，默认）	降序（DESC）	
				注意：order by 写在最后，最后才进行查询
				eg.
					将英雄的防御值由低到高排序
					mysql > select * from sanguo 
    					     -> order by fangyu ASC;
					将蜀国英雄按攻击值从高到低排序
					mysql> select * from sanguo where country ="蜀国"  order by gongji DESC;
					将魏蜀两国的男英雄名字中名字为三个字的英雄按防御值升序排列
					 mysql> select * from sanguo  where country in("魏国","蜀国") and sex = "man" and name like "___" order by fangyu asc;
						
					
			 b.limit （永远放在sql语句最后）		
				作用：限制你需要的记录个数
				用法：limit n		显示前n条
				      limit m,n		从第m+1条开始（因为从0开始计数），显示n条记录，m相当于C数组下标
				eg.查找防御值倒数第2名到倒数第四名的蜀国英雄记录
				  mysql  > select * from sanguo 
    					-> where country ="蜀国"
   					-> order by fangyu asc
    					-> limit 1,3;
 				    查找攻击值前三名且名字不为空的蜀国英雄的姓名，攻击值，和国家
					mysql    > select name ,gongji ,country from sanguo
    						-> where country="蜀国" and name !=""
    						-> order by gongji desc
    						-> limit 0,3;
	
			c.聚合函数
				分类：	
					1）avg（字段名）	：求字段的平均值
					2）sum（字段名）	:求和
					3）max 与 min(字段名)	：求最值
					4）count（字段名）	：取字段的记录个数
					例子：
						统计id和name字段的个数
						select count（id）,count（name） from sanguo;
						mysql> select count(id) as IDNumber from sanguo;
						+----------+
						| IDNumber |
						+----------+
						|        9 |
						+----------+
					注意:as取的别名；NULL空值不会被统计，但空字符串会被统计
				             count（*）可以统计所有，但不建议这样使用

						统计蜀国英雄中攻击值大于200的英雄数量
						select count（*）from sangguo	
						where gongji>200 and country ="蜀国";	
						mysql    > select count(*) from sanguo 
   							 -> where 
   							-> country ="蜀国" and gongji>200;
						+----------+
						| count(*) |
						+----------+
						|        2 |
						+----------+
						1 row in set (0.04 sec)
			d.group by 分组
				给查询的结果进行分组，一般和聚合函数一起使用
				例子： 
					select country from sanguo group by country
					+---------+
					| country |
					+---------+
					| 吴国    |
					| 蜀国    |
					| 魏国    |
					+---------+

				注意：group by 先分组再聚合

				例子:计算所有国家的平均攻击力
				     先进行分组，再算各个国家的平均攻击力
				      mysql > select country ,avg(gongji) from sanguo
   					   -> group by country;
					+---------+-------------+
					| country | avg(gongji) |
					+---------+-------------+	
					| 吴国    |    100.0000 |
					| 蜀国    |    440.5000 |
					| 魏国    |    392.5000 |
					+---------+-------------+
					执行过程是：先分组（还未去重）	group by country
						    再聚合（求攻击力的平均值）	
						    最后去重
				 例子：查找所有国家中，英雄数量最多的前两名
					mysql> select country ,count(name) from sanguo
    					    -> group by country
  					    -> order by count(name) desc;
					+---------+-------------+
					| country | count(name) |
					+---------+-------------+
					| 蜀国    |           5 |
					| 魏国    |           2 |
					| 吴国    |           1 |
					+---------+-------------+
					3 rows in set (0.01 sec)
				
		e.having 
			作用：对条件的进一步筛选（类似于where ，但where处理不了的筛选）
			       
			注意：where只能对表中原始数据进行一定的筛选，但要是用聚合函数后再对算出的数据进行筛选就用having

			例子：找出平均攻击力大于105的国家的前两名，显示国家名称和平均攻击力
			      
				mysql	 > select country,avg(gongji) as avg_gongji from sanguo
    					-> group by country
    					-> having avg_gongji > 105
   				        -> order by avg_gongji desc
    					-> limit 2;
				+---------+------------+
				| country | avg_gongji |
				+---------+------------+
				| 蜀国    |   440.5000 |
				| 魏国    |   392.5000 |
				+---------+------------+
			说明：group by 一般对字段进行分组，聚合函数对分组后的数据进行进一步地操作，如：计算各组平均数avg，
			求和sum，计数count等，而having对聚合后数据地再次筛选，比如像上面的例子一样，筛选出gongji大于105
			的平均数所在的国家

			例子：
				
				mysql> select sex,avg(gongji) from sanguo group by sex;
				+-------+-------------+
				| sex   | avg(gongji) |
				+-------+-------------+
				| man   |    265.2857 |
				| woman |    835.5000 |
				+-------+-------------+


	distinct：
		可以用于去除，当然group by分组也可以去重
		使用：sanguo表中有几个国家
		      select distinct country from sanguo	去除国家的重复的
		      select distinct country ，name from 	当country和name对应的一行数据有与之完全相同的一行才被去重
		例子：计算蜀国有多少个英雄
			mysql	  >  select count(distinct name) from sanguo 
   				 ->  where country ="蜀国";
		
		注意：distinct不能对任何字段作聚合处理

	
	在查询表的时候可以做数学运算：
			1.运算符
				+ - * /
			2.例子：
				在查询显示英雄攻击时*10
				 select name,gongji*10,country from sanguo;
				
		

	约束：
		约束通常是创建表时，给与字段约束
		1.作用:在插入数据到表时，限制约束输入，以保障数据的有效性，完整性，一致性
		2.约束的分类：
			1）默认约束（default）：
				说明：在插入时如果不给值，那么自动设置默认值; 通常是在创建表的时候，指定默认值
				格式：字段名 数据类型 default 默认值
				例子1: 修改字段sex的类型 并设置默认值
					alter table classmates modify sex enum("男","女","保密") default "保密";
			2）非空约束：
				说明：不允许字段有空值
				格式：字段名 数据类型 not null
			3）索引（很重要）：	 
				优缺点要知道！
				定义：对数据库中表的一列或者多列的值进行排序的一种结构（MYSQL中索引用Btree方式）
				       BTree：	
						
				优点：加快数据检索速度，减少了很多无效的查询。
				缺点：a.因为表中的数据随时可能在更新，那么整个索引就要动态地不断变化，就需要不断维护，
				      间接影响查询速度
				      b.索引需要占用物理存储空间（/var/lib/mysql）
				
				示例：
					1.执行insert.py文件在数据库中插入一百万条记录，字段有两个
					2.开启性能测试：show variables like "%pro%"
					  将其中的profiling设置为1：set profiling = 1;
					3.执行查询语句：select name from t1 where name = "lucy999999";
					4.查看性能分析结果：show profiles;	
				          结果为0.332s
					（此时还未加索引）
					5.添加索引:create index name on t1;	
					  创建索引后：desc t1;查看表结构发现：多了key列，在对应的name字段下，多了mul
					  MUL：即为name字段添加的索引
					6.现在,添加索引后,执行：select name from t1 where name ="lucy9999999"
					7.执行：show profiles;
					  查询分析结果
					  结果为：0.019s			
				
					8.所以，这就是差别！至少目前，无它不行！查询时候非常关键！性能~
		

		课后面试题：mysql > select use_id,count(commit_id) from comment
   					 -> group by use_id
    				 -> order by count(commit_id) desc
   					 -> limit 10;

	索引
		分类：普通索引，唯一索引，主键索引，外键索引
		
		1.普通索引（index）
			使用规则：一张表中可以为多个字段设置index索引；
				  字段值没有约束（可以有重复，有空）；
				  常需要查询的字段可以设置索引

			index字段的key标志位：MUL
			
			创建表时添加索引：create table t1（
						id smallint,						.
						index(id));
			在已有表中为字段添加索引名：create index 索引名 on 表名（字段名）;		#索引名一般和字段名一样
			
			查看索引：desc 表名； 或者 show index from 表名[\G];

			删除索引:drop index 索引名 on 表名;

			注意:删除普通索引，只能一个一个删除

		2.唯一索引（unique）

			使用规则：一个表中可以有多个unique字段；unique字段不予许有重复值，但可以为空；
			标志位：UNI
			创建：
				创建表时：create table 表名（ID smallint，unique（ID));
				已有表中：create unique index 索引名 on 表名（字段名）;
			查看：desc 表名  或  show index from 表名;
			
			删除：drop index 索引名 on 表名;

		3.主键索引（primary key）  & 自增长属性（比如id，添加一项自动增加1）

			使用规则：一个表中只有一个主键，通常是把记录ID的字段设置为主键，每个值都是唯一的；对应字段的值不允许重复和空值
			key标志：PRI
			主键：唯一标识一条记录
			创建：
				创建表时创建：create table 表名(
							 	... ... ,
							 	字段名 数据类型 primary key auto_increment,
							 	... ...
								);
							也可以：create table 表名(
							 	... ... ,
							 	id smallint auto_increment,
							 	name varchar(20),
							 	primary key(id,name)	#复合主键，一般一个表中只有一个主键。基本很少使用
							 	）；
							 eg.mysql>  create table t1(
  	  								-> id int primary key auto_increment,
  								    -> name char(20)) auto_increment=10;		#指定id从10开始编号
								Query OK, 0 rows affected (0.06 sec)

								mysql> desc t1;	
								+-------+----------+------+-----+---------+----------------+
								| Field | Type     | Null | Key | Default | Extra          |
								+-------+----------+------+-----+---------+----------------+
								| id    | int(11)  | NO   | PRI | NULL    | auto_increment |
								| name  | char(20) | YES  |     | NULL    |                |
								+-------+----------+------+-----+---------+----------------+
								2 rows in set (0.01 sec)
				在已有表中创建主键：
						alter table 表名 add primary key（字段名） ；
						添加自增长属性：alter table 表名 modify 字段名 数据类型 auto_increment;				

			删除主键：
				设置了自增长属性的字段，要想其主键被删除掉，首先删除自增长属性auto_primary
				先删除自增长属性（modify）：
				alter table 表名 modify id int;
				再删除主键：
				alter table 表名 drop primary key;

		外键索引

			作用：保证数据一致性。让多张表关联起来
			定义 让当前表字段的值在另外一个表的范围内选择
			语法：
				foreign key(参考字段名)					#当前表
				references 被参考表名（被参考字段名）		#参考表
				on delete 级联动作
				on update 级联动作
			例子：
				有两张表：						
					表1:缴费信息表（财务）（主表）
					学号 	姓名 	班级  	金额
					 1    	唐伯虎	一班		2000
					 2		秋香		一班		1999

					 表2：学生信息表（班主任）（从表）
					 学号	姓名  	缴费金额
					 1		唐伯虎	2000
					 2		秋香		1999
				表1：mysql> create table payment(
    					 -> id int primary key auto_increment,
    					 -> name char(15),
					     -> class char(5),	
    				 	 -> money int,
    				 插入数据： insert into payment values(1,"唐伯虎","AID001",20000)，(1,"秋香","AID001",21000)					  ，(3,"祝枝山","AID001",22000);

    			表2：mysql> create table student(
  					     -> stu_id int,
      	 				 -> name char(15),
    					 -> money int，
    					 #设置外键，当前表student字段id跟随payment表字段id，同步更新及删除
    					 -> foreign key(stu_id) references payment(id)
    					    on delete cascade 
    					    on update cascade
    					 )default charset=utf8;
		 	 		这时，
		 	 		只有当表1有记录时，表2才可插入与之相对的记录。表2无法插入表1中没有的记录，这时就用表1来控制表2的记录
		 	 		注意：主表id和从表的id要一一对应才可，值上要对应		 	 

		 	级联动作:
		 	 		cascade 	数据级联更新			说明：主表更新删除，从表随着更新删除
		 	 		restrict 	限制主表更新删除 		说明：当删除或更新主表时，如果从表有与之相关联记录则不允许主表删除
		 	 		set null 	从表设空				说明：当主表删除记录或更新时，从表中相关联记录的参考字段自动设置为NULL
		 	 		no action 	类似restrict			说明：主表更新删除，立即检查外键关联。


		 	删除外键：
		 			alter table 表名 drop foreign key 外键名;

		 	查看外键：show create table 表名;

		 	在已有表中添加外键：
		 			PS：会受到已有数据限制			
		 			格式：
		 			alter table 表名 add 
		 			foreign key（参考字段名）references 被参考表名(被参考字段) 
		 			on delete 级联动作	 	  
		 			on update 级联动作;

			外键的使用规则：被参考字段（主表中）与参考字段的数据类型一致，被参考字段一般是主键字段（不允许为空及重复）

		数据导入

			导谁：文件系统内容，导入到数据库中
			语法：
				load data infile "文件名绝对路径"
				into table 表名
				fields terminated by "分隔符"		#分隔字段读入
				lines terminated by "\n"			#遇到\n则导入了一条记录
			例子：
				导入/etc/passwd下的文件到数据库表中
				在这个文件内，有若干条用户信息（每个软件安装后都会有一条信息，但除了root和自己的账号都没有登录权限）
				例如：ran:x:1000:1000:Lucky,,,:/home/ran:/bin/bash
				这就是一条我的信息
				用户名 密码     UID号		GID号 	用户描述		用户主目录	   登录权限
				ran  :  x  :   1000 :   1000 : Lucky,,, : /home/ran   :  /bin/bash
																		/bin/false
																		/usr/sbin/nologin
 			现在来操作：
 				1.创建表
 				2.将需要导入到数据库的文件拷贝到数据库的默认搜索路径
 				  第一步：查看数据库的默认搜索路径： show variables like "secure_file_priv";
 				  	一般为：/var/lib/mysql-files
 				  第二步：sudo cp /ect/passwd /var/lib/mysql-files/
 				3.执行数据导入语句：
 				  		 load date infile "/var/lib/mysql-files/passwd"
 				  		 into table usertable
 				  		 fields terminated by ":"
 				  		 lines terminated by "\n";
 				PS:当导入csv文件时，其分隔符为逗号","。
 					Excel文件可以先转为CSV文件。再创建表，将文件放入数据库默认搜索路径，再将文件内容读入到数据库中的表中。
 	    数据导出

 	    	作用是：将数据库表中的数据保存到系统文件中去
 	    	语法：
 	    		select ... from 表名
 	    		into outfile "文件路径"
 	    		fields terminated by "分隔符"
 	    		lines terminated by "\n";
 	    	来个练习：将上面数据导入中的表中导出
 	    			 msql> select use_name,password,UID from usetable
    					-> into outfile "/var/lib/mysql-files/haha.txt"
    					-> fields terminated by ","
    					-> lines terminated by "\n";
					Query OK, 35 rows affected (0.16 sec)
 	    	注意:1.导出的字段可以自己指定导入数据库表中哪些字段 2.文件路径必须是数据库的搜索路径 	

 	    利用已有表快速创建（复制）一张表： 	   
 	    	create table 表名 select 查询命令;
 	    	练习：1.复制usetable表中的全部记录，放于usetable2
 	    	 	    create table usetable2 select *from usetable;
 	    	 	  2.复制usetable中username,password，uid三个字段的第2-10条记录，放于usetable3
 	    	 	    create table usetable3 select username，password，uid from usetable limit 1-9;

 	    复制表结构：
 	    	复制一张表的结构，但内容为空。
 	    	PS：复制出来的表结构不会保留原表的key属性，比如：主键，外键
 	    	create table 表名 select 查询命令 where false;

 	    嵌套查询（子查询）
 	    	select内嵌套多个select
 	    	定义：将内层的查询结果，作为外层的查询条件
 	    	例子：将usetable中UID的值小于UID平均值的用户名和UID号显示出来
 	    		select usename,UID from usetable
 	    		where UID < (select avg(UID) from usename);
 	    	注意：子查询耗费资源多，尽量不用

 	    	insert into xian values(1,"132100","正定县","131100"),(2,"132102","浦东新区","131112"),(3,"132103","武昌区","131108"),
 	    	(4,"132104","哈哈","131115"),(5,"132105","安新县","131114"),(6,"132106","容城县","131114"),(7,"132107","雄县","131114"),(8,"132108","嘎嘎","131115");


 	    连接查询（多张表连接起来查询，形成一张“大表”）：

 	    	1.内连接
 	    		表中不显示与被连接表中未匹配到的记录
 	    		语法：
 	    			select 字段名/字段名列表 from 表1
 	    			inner join 表2 on 条件 
 	    			inner join 表3 on 条件 
 	    			...
 	    		实例：
 	    			现在有一个表sheng，表city在数据库中。
 	    			1.显示省市的详细信息
 	    			mysql > select sheng.S_name,city.c_name from sheng
    					 -> inner join city
     					 -> on sheng.s_id = city.cfather_id;
     				该例子通过内连接连接起来了，通过省的代码连接上了
     				+-----------+--------------+
					| S_name    | c_name       |
					+-----------+--------------+
					| 河北省    | 石家庄市     |
					| 河北省    | 沧州市       |
					| 河北省    | 廊坊市       |
					| 陕西省    | 西安市       |
					| 四川省    | 成都市       |
					| 四川省    | 重庆市       |
					| 广东省    | 广州市       |
					| 山东省    | 济南市       |
					| 湖北省    | 武汉市       |
					| 河南省    | 郑州市       |
					+-----------+--------------+
					10 rows in set (0.05 sec)

					2.显示省市县详细信息（三张表进行关联，主要还是用表两两之间的共同字段进行关联）
					mysql> select sheng.s_name,city.c_name,xian.x_name from sheng
    				    -> inner join city on s_id=cfather_id
    					-> inner join xian on c_id=xfather_id;
					+-----------+--------------+-----------+
					| s_name    | c_name       | x_name    |
					+-----------+--------------+-----------+
					| 河北省    | 石家庄市     | 正定县    |
					| 湖北省    | 武汉市       | 武昌区    |
					+-----------+--------------+-----------+
					2 rows in set (0.03 sec)

 	    	2.外连接
 	    		左连接
 	    			定义：以左表为主，显示查询结果
 	    			语法：
 	    				select 字段名列表 from 表1
 	    				left join 表2 on 条件
 	    			实例：以省表为主，显示详细信息
 	    			mysql> select sheng.s_name,city.c_name from sheng
   					    -> left join city on sheng.s_id=city.cfather_id;
					+-----------+--------------+
					| s_name    | c_name       |
					+-----------+--------------+
					| 河北省    | 石家庄市     |
					| 河北省    | 沧州市       |
					| 河北省    | 廊坊市       |
					| 陕西省    | 西安市       |
					| 四川省    | 成都市       |
					| 四川省    | 重庆市       |
					| 广东省    | 广州市       |
					| 山东省    | 济南市       |
					| 湖北省    | 武汉市       |
					| 河南省    | 郑州市       |
					| 海南省    | NULL         |
					| 云南省    | NULL         |
					| 山西省    | NULL         |
					+-----------+--------------+
					13 rows in set (0.01 sec)

					mysql> select sheng.s_name,city.c_name,xian.x_name from sheng
    				-> left join city on sheng.s_id=city.cfather_id
				    -> left join xian on city.c_id=xian.xfather_id;
					+-----------+--------------+-----------+
					| s_name    | c_name       | x_name    |
					+-----------+--------------+-----------+
					| 河北省    | 石家庄市     | 正定县    |
					| 河北省    | 沧州市       | NULL      |
					| 河北省    | 廊坊市       | NULL      |
					| 陕西省    | 西安市       | NULL      |
					| 四川省    | 成都市       | NULL      |
					| 四川省    | 重庆市       | NULL      |
					| 广东省    | 广州市       | NULL      |
					| 山东省    | 济南市       | NULL      |
					| 湖北省    | 武汉市       | 武昌区    |
					| 河南省    | 郑州市       | NULL      |
					| 海南省    | NULL         | NULL      |
					| 云南省    | NULL         | NULL      |
					| 山西省    | NULL         | NULL      |
					+-----------+--------------+-----------+
					13 rows in set (0.01 sec)

 	    		右连接	
 	    			以右表为主，显示查询结果
 	    			语法格式：select 字段名列表 from 表1
 	    					 right join 表2 on 条件表达式;
 	    			mysql> select sheng.s_name,city.c_name,xian.x_name from sheng
					    -> right join city on sheng.s_id=city.cfather_id
					    -> right join xian on city.c_id=xian.xfather_id;
					+-----------+--------------+--------------+
					| s_name    | c_name       | x_name       |
					+-----------+--------------+--------------+
					| 河北省    | 石家庄市     | 正定县       |
					| NULL      | 上海市       | 浦东新区     |
					| 湖北省    | 武汉市       | 武昌区       |
					| NULL      | NULL         | 哈哈         |
					| NULL      | 雄安新区     | 安新县       |
					| NULL      | 雄安新区     | 容城县       |
					| NULL      | 雄安新区     | 雄县         |
					| NULL      | NULL         | 嘎嘎         |
					+-----------+--------------+--------------+
					8 rows in set (0.00 sec) 	    					

					PS：匹配不到的就显示为空

					显示省市县详细信息，要求市全部显示：
						这涉及到左右连接的混合搭配
						mysql> select sheng.s_name,city.c_name,xian.x_name from sheng
					    -> right join city on sheng.s_id = city.cfather_id
					    -> left join xian on city.c_id=xian.xfather_id;
						+-----------+--------------+--------------+
						| s_name    | c_name       | x_name       |
						+-----------+--------------+--------------+
						| 河北省    | 石家庄市     | 正定县       |
						| 河北省    | 沧州市       | NULL         |
						| 河北省    | 廊坊市       | NULL         |
						| 陕西省    | 西安市       | NULL         |
						| 四川省    | 成都市       | NULL         |
						| 四川省    | 重庆市       | NULL         |
						| 广东省    | 广州市       | NULL         |
						| 山东省    | 济南市       | NULL         |
						| 湖北省    | 武汉市       | 武昌区       |
						| 河南省    | 郑州市       | NULL         |
						| NULL      | 北京市       | NULL         |
						| NULL      | 天津市       | NULL         |
						| NULL      | 上海市       | 浦东新区     |
						| NULL      | 哈尔滨市     | NULL         |
						| NULL      | 雄安新区     | 安新县       |
						| NULL      | 雄安新区     | 容城县       |
						| NULL      | 雄安新区     | 雄县         |
						+-----------+--------------+--------------+

						17 rows in set (0.00 sec)

			多表查询:
				笛卡尔积查询：	多张表查询
						 		select * from 表1，表2;
						 		说明：将表1中的每一条记录与表2中的每一条记录各匹配一次，形成一张大表
						 		但是，若在此查询语句基础上	，在加上where条件语句后，等同于内连接查询


			如何连接到远程数据库？
			MySQL用户账户管理：
					1.开启远程连接
						1.获取root权限
							sudo -i
						2.切换到配置文件所在路径
							cd /etc/mysql/mysql.conf/
						3.vi mysql.cnf(注释本地连接)
							#bind-address = 127.0.0.1
							Vi使用：
									vi刚进去时时浏览模式->按a，进入插入模式->ESC，退出到浏览模式	->shift+:，命令行模式->
									输入wq，保存并退出
						4.重启mysql服务			
					2.添加授权用户 
						1.使用root用户连接到服务器
							mysql -uroot -p密码
						2.添加新的授权用户
							create user "用户名"@"IP地址" identitfied by "密码"
							例如：create user "ran"@"%" identified by "123456"
							IP地址的表示方式：
								1.%表示任意IP地址都可以连接到服务器
								2.localhost表示用户只能从本地连接
								3.其他特定IP，只有与该IP绑定的用户才可连接到服务器
					3.给用户权限
						Linux下IP地址查看：ifconfig
						查看已有用户:select user,host from mysql.user;
						授权语句：
							grant 权限列表 on 库名.表名 to "用户名"@"IP地址" with grant option;
						   （其中的with grant option代表用户可以再次给其他用户授权）
						    例：
						    	grant delete,select,alter on 库.表 to "ran"@"IP地址" with grant option;
						    	最高权限：
						    		grant all privileges on *.* to "用户名"@"IP地址" with grant option;
						    权限列表：select，delete，update，insert，alter，drop，create··
						    *.*代表所有库的所有表都可以操作
						删除用户：
							drop user "用户"@"IP地址";
						练习：
							1.添加一个用户：monkey，所有人都可以连接，只对myDB库由查询权限
							2.为monkey用户授权
							3.验证：mysql -hIP地址 -u用户名 -p密码
							create user "monkey"@"%" identified by "rjy";
							grant select on myDB.* to "monkey"@"%" with grant option;
							mysql -hIP地址 -umonkey -prjy;

			数据备份（linux终端下备份）：
				1.格式：		mysqldump -uroot -p 原库名 > 路径/xxx.sql
				2.原库名的表示：
					--all-databases	    备份所有库
					库名 				备份单个库
					-B 库1 库2...		备份多个库
					库名 表1 表2...		备份指定库中的表
				3.例子：
					备份myDB（备份的是sql命令）
					mysqldump -uroot -p myDB > /home/ran/

			数据恢复：
				1.格式：mysql -uroot -p 要恢复的目标库名 < 路径/备份文件.sql 
			 	  注意：要恢复的目标库名必须存在
			 	2.步骤：
			 		先备份库->再删除库->再创建空库->再恢复
			    3.备份分为：完全部分 与 增量备份
			    		完全备份：mysqldump
			    		增量备份：binlog日志，xbackup工具
			    4.如何从所有库的备份文件中只恢复某一个库？
			    	使用：--one-database
			    	语法：mysql -uroot -p --one-database 需要恢复的库名（库名需要与原库名一致） < 所有备份.sql
					备注：
						若在恢复前，库中有新增的表时，而新增的表没有在备份里，新增表不会因恢复而被覆盖或删除
						恢复时，必须先创建空库

			事务与事务回滚
				1.事务的定义：一件事发生的开始到结束整个过程
				2.作用：确保数据的一致性
				mysql中sql语句会自动提交到数据库中，而Oracle中却需要管理员输入commit命令后才可提交到数据库
				在mysql中，使用：show variables like "autocommit"； 可以查看是否设置为了自动提交
				3.事务应用：
					a.开启事务
						mysql> start transaction;
						mysql> ...一系列sql命令后回车
						#上面两条执行后，没有提交操作到数据库，因为此时autocommit被禁用了
					b.终止事务	
						mysql> commit;	输入此命令后，此时才提交之前的 sql操作
					c.注意：
						事务回滚只对表的记录一系列的操作(增删改查)才有作用，对表的创建、库的创建没有作用
						比如说：银行转账的过程，其中如果某个环节出现了问题就可以回滚来撤销之前的操作，而不对的数据造成修改。
								保护了数据安全。只有在整个过程没有出现问题后，最终才commit更新数据库，一旦出现了错误可以回滚rollback

			mysql里的存储引擎：
				1.定义：处理表的处理器
				2.存储引擎的基本操作：
					查看已有表的存储引擎：show create table 表名;		#输入该命令后，就可以查看表的存储引擎是什么，即查看其Engine=...
				3.创建表时指定存储引擎：
					create table 表名（...） engine=myisam;
				4.查看所有的存储引擎：
					show engines\G;	InonDB为默认存储引擎
				5.InnoDB介绍：
					Engine: InnoDB
				     	Support: DEFAULT
				     	Comment: Supports transactions（支持事务）, row-level locking（行级锁）, and foreign keys（外键）
					 	Transactions: YES
				        XA: YES
				     	Savepoints: YES
				6.另外一个常用的引擎：
						Engine: MyISAM
					     Support: YES
					     Comment: MyISAM storage engine
					Transactions: NO
					          XA: NO
					  Savepoints: NO
				7.上述两种引擎区别与特点：
					innoDB特点：
						a.共享表空间（存一起）：
							在/var/lib/mysql/内
							表名.frm 		储存表结构
							表名.idb 		表记录和索引信息
							注意：在学习mysql时的版本较视频中的版本有所更新，里面只有一个frm表（猜测无论是表结构还是记录或是索引都	   存在frm中，更加地共享了）
						b.支持行级锁
							比如一条记录在进行操作时，锁住，只能让一个人改。
					myisam特点：
						a.独享表空间（分开存）
							表名.frm 		存表结构
							表名.myd 		存表记录
							表名.myi 		存索引信息
						b.支持表级锁
				8.锁（mysql自动加锁）：
					加锁的目的：为了解决客户端并发访问时的冲突问题
					锁的类型：
						读锁（select时，又称共享锁）			加了读锁后，每个人都可以查询，但不可改数据。
						写锁（增删改时，又称互斥锁、排他锁）	有一个人在操作时，其他人都不可操作 	
					###操作完成后自动释放锁###
				9.锁粒度	
					表级锁
					行级锁
			   *10.在实际中如何选择引擎？
					执行查询操作多时，创建表时指定MyISAM为引擎(因为锁表比锁行快得多，Innodb浪费资源)
					执行写操作多时，使用InnoDB引擎（因为支持行级锁，如果用MyISAM时，一写就把表锁住了，别人就无法操作自己的一条记录）
				11.如何更改数据库的默认存储引擎：
					a.sudo -i
					b.cd /etc/mysql/mysql.conf
					c.gedit mysql.cnf
					d.修改内的语句： 	default-storage-engine = myisam  
					e.保存退出
					f.重启mysql服务 service mysql restart
				12.memory存储引擎：
					表存储在内存中，读写速度快，但表内数据易挥发，断电（或数据库服务重启、关闭）就没了
					表名.frm 存储表结构
					注意：重启服务后，表结构在，但表记录会消失
		
			MySQL基础查询优化：
				1.选择合适引擎
					查询较多的用MyISAM
					写比较多的用Innodb
				2.基本SQL语句优化（写好的语句）
					尽量避免全表查询
					方法1：建立索引（经常用的字段建立索引）
					方法2：where语句中，尽量不要使用！=，因为一旦使用索引将不会被使用，而且是全表查询
					方法3：尽量不要使用NULL来判断，因为一旦使用索引将不会被使用，而且是全表查询。
						   尽量给NULL赋予默认值，如：0
						   示例：select id from t1 where number=null
						   优化：给number字段设置默认值0						 
					方法4：尽量避免使用or来连接条件，因为也会全表扫描
						   示例：select id from t1 where id=10 or id=20
						   优化：select id from t1 where id=10 
						         union all 
						         select id from t1 where id=20
						         #union all 语句将两条语句连接在一起，相当于先后单独执行一次select						  
					方法5：尽量避免使用前置%，导致全表查询（模糊查询）
						   示例：select id from t1 where name="%a"
					方法6：尽量避免使用in 和 not in ，导致全表扫描
						   示例：select id from t1 where id in（1,2,3）;
						   优化：可以使用union all来连接 或者 使用between 1 and 3
					方法7：尽量避免使用*，尽量使用具体字段来查询
				
			python数据库编程

				1.python数据库接口
					用于连接数据库的python接口
					可以支持的数据库：mysql，Oracle，MongoDB，Sql-Server（python模块不同）
				2.支持mysql的数据库接口模块
					python3：pymysql
					python2：MySQLdb
				3.pymysql使用流程：
					a.先连接数据库
					b.创建游标对象（相当于一个实例）
					c.使用游标对象的方法操作数据库
					d.提交commit
					e.关闭游标对象
					f.关闭数据库连接
					示例：
						#!usr/bin/python
						import pymysql

						#连接到数据库
						db=pymysql.connect("localhost","root","rjy","myDB",charset="utf8")
						#创建游标对象
						cursor=db.cursor()
						# 操作游标对象，对数据库进行操作，括号内为sql语句
						cursor.execute("insert into shool values(1,'zhangsan','Beijing');")



				
















 










	
	

